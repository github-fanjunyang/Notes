---
title: 面试题汇总 
---  
[toc]   



## Vue面试题  



### 004.路由嵌套  
路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转。  
router-view本身就是将组件渲染到该位置，  

 

### 008.route 和 router 的区别是什么？  
route是“路由信息对象”，包括path,params,hash,query,fullPath,matched,name等路由信息参数。  

router是“路由实例对象”，包括了路由的跳转方法(push、replace)，钩子函数等。  




### 000.web缓存  
数据库缓存、服务器端缓存、浏览器端缓存  
* 减少网络带宽消耗  
* 降低服务器压力  
* 减少网络延迟，加快页面打开速度  

### 011.vuex面试相关    

(1)vuex是什么?  

vue框架中状态管理。  

(2)vuex有哪几种属性?  

有五种，分别是 State、 Getters、Mutations 、Actions、 Module  

vuex的State特性  

A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data  

B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新  

C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中  

vuex的Getters特性  

A、getters 可以对State进行计算操作，它就是Store的计算属性  

B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用  

C、 如果一个状态只在一个组件内使用，是可以不用getters  

vuex的Mutations特性  

Actions 类似于 mutations，不同在于：Actions 提交的是 mutations，而不是直接变更状态;Actions 可以包含任意异步操作。  

(3)不用Vuex会带来什么问题?  

可维护性会下降，想修改数据要维护三个地方;   

可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的;  

增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。   

同步异步区别：  
1、流程顺序  
“相应视图—>修改State”拆分成两部分，视图触发Action，Action再触发Mutation。  
2、角色定位  
基于流程顺序，二者扮演不同的角色。  
Mutation：专注于修改State，理论上是修改State的唯一途径。  
Action：业务代码、异步请求。  
3、限制  
角色不同，二者有不同的限制。  
Mutation：必须同步执行。  
Action：可以异步，但不能直接操作State。   

Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。  
每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。**如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难**。

### 012.如何让CSS只在当前组件中起作用  
将当前组件的\<style>修改为\<style scoped>  


### 014.谈谈你对虚拟DOM的理解？  
首先,我们都知道在前端性能优化的一个秘诀就是尽可能少地操作DOM,不仅仅是DOM相对较慢,更因为频繁变动DOM会造成浏览器的回流或者重绘,这些都是性能的杀手,因此我们需要这一层抽象,在patch过程中尽可能地一次性将差异更新到DOM中,这样保证了DOM不会出现性能很差的情况.  

其次,现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能,多人协作的项目中如果review不严格,可能会有开发者写出性能较低的代码,另一方面更重要的是省略手动DOM操作可以大大提高开发效率.  

### 015.Vue 中 key 值的作用？  
当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟DOM。  

### 016.vue 中怎么重置 data?   
vue实例中的\$options保留了初始化组件中的所有状态  
使用`Object.assign()`，`vm.$data`可以获取当前状态下的data，`vm.$options.data`可以获取到组件初始化状态下的data。  
`Object.assign(this.$data, this.$options.data())`  

### 017.组件中写 name 选项有什么作用？  
* 项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤  
* DOM 做递归组件时需要调用自身 name  
* vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的  

### 018.为什么需要 nextTick?  
Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改--刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。   
$nextTick()是等待dom更新完才会执行的回调  

### 019.vue 首屏加载优化方案  
* 把不常改变的库放到 index.html 中，通过 cdn 引入  
* vue 路由的懒加载  
* 不生成 map 文件（找到 config/index.js，修改为 productionSourceMap: false）  
* vue 组件尽量不要全局引入  
* 使用更轻量级的工具库  
* 开启gzip压缩  
* 首页单独做服务端渲染  

### 020.Vue3.0 有没有过了解？  
关于Vue 3.0，大致说了三个点，第一个是关于提出的新API setup()函数，setup创建组件实例时，在初始组件解析后立即调用。在生命周期方面，它在beforeCreate和created之前被调用（2.x），第二个说了对于Typescript的支持，最后说了关于替换Object.defineProperty为 Proxy 的支持。  
  
详细说了下关于Proxy代替带来的性能上的提升，因为传统的原型链拦截的方法，无法检测对象及数组的一些更新操作，但使用Proxy又带来了浏览器兼容问题。  

### 022.NextTick 是做什么的?  
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM  

### 023.Vue 组件 data 为什么必须是函数?  
因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了  

### 024.计算属性computed 和事件 methods 有什么区别  
我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的  

不同点：  
* computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值  
* 对于 method ，只要发生重新渲染，method 调用总会执行该函数  

[Vue中watch、computed与methods的联系和区别](https://juejin.im/post/5dc97336e51d456929657092)  



### 028.常见的跨域解决方案  
前端配置vue.config.js  
后端配置  
jsonp（只能解决get）      
>步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据  


[常见的跨域解决方案](https://juejin.im/post/5d52a4fe518825163b090495)  

### 029.什么是webpack及其优点  
* 打包：可以把多个JavaScript文件打包成一个文件，减少服务器压力和下载宽带  
* 转换：把扩展语言转换成为普通的JavaScript，让浏览器顺利运行。  
* 优化：肩负起了优化和提升性能的责任    


### 031.Vue递归组件的使用  
[递归组件](https://juejin.im/post/5d53f8726fb9a06b0b1c6df0)  

### 032.Vue的mode中hash与history的区别  
hash模式重新加载的时候只加载#后面的   
history模式则是整个地址重新加载，不过他可以保存历史记录，方便前进后退    

vue-router 有 3 种路由模式：hash、history、abstract   
* hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；  
* history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；  
* abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.   

### 033.vue中常用的命令  
v-if   v-show区别  
v-for  
v-model  
v-bind  
v-on    

### 034.Vue 的父组件和子组件生命周期钩子函数执行顺序？  
Vue 的父组件和子组件生命周期钩子函数执行顺序？  
* 加载渲染过程  
父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted  
* 子组件更新过程  
父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated  
* 父组件更新过程  
父 beforeUpdate -> 父 updated  
* 销毁过程  
父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed  

### 035.在哪个生命周期内调用异步请求？  
可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
* 能更快获取到服务端数据，减少页面 loading 时间；  
* ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；  

### 036.组件中 data 为什么是一个函数？  
因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响。  

如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。  

### 037.Vue组件间通信有哪几种方式？  
* props  
* $emit  
* $attr  
* $listener  
* provide  inject  (隔代通信)  
* $parent  $children  
* vuex  

### 038.Proxy 与 Object.defineProperty 优劣对比  
Proxy 的优势如下:  
* Proxy 可以直接监听对象而非属性；  
* Proxy 可以直接监听数组的变化；  
* Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；  
* Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；  
* Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；  
Object.defineProperty 的优势如下:  
* 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。  

### 039.虚拟 DOM 的优缺点？  
优点：  
* 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；  
* 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；  
* 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。  

缺点：  
* 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。    

### 040.虚拟 DOM 实现原理？  
虚拟 DOM 的实现原理主要包括以下 3 部分：  
* 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；  
* diff 算法 — 比较两棵虚拟 DOM 树的差异；  
* patch 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。  

### 041.vue插槽的使用？  
默认插槽  
具名插槽  
作用域插槽  

### 042.active-class是哪个组件的属性？  
vue-router模块的router-link组件，主要用来控制点击样式问题。  

### 043.怎么定义vue-router的动态路由以及如何获取传过来的动态参数？  
在router目录下的index.js文件中，对path属性加上/:id。
使用route对象的`params.id`

### 044.vue-loader是什么？使用它的用途有哪些？  
vue文件的一个加载器。  
用途：js可以写es6、style样式可以scss或less、template可以加jade等根据官网的定义，  
vue-loader 是 webpack 的一个 loader，用于处理 .vue 文件.  

### 045.为什么避免 v-if 和 v-for 用在一起？  
当Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着v-if将分别重复运行于每个v-for循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。    

### 046.vue中Class 与 Style 如何动态绑定？  
[Vue Class与Style绑定](https://juejin.im/post/5da1990b51882518fa5a3877)  

### 047.怎样理解 Vue 的单向数据流？  
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。  

额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。    

### 048.直接给一个数组项赋值，Vue 能检测到变化吗？  
由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：  
* 当你利用索引直接设置一个数组项时，例如：vm.items\[indexOfItem] = newValue  
* 当你修改数组的长度时，例如：vm.items.length = newLength  

### 049.vue.js的核心是什么？  
* 数据驱动（响应式）：data中的数据变了，视图才会变  
* 组件化：拆组装，目的在于重用，方便，脏活累活一次干完，之后就轻松了     

### 050.vue的常用修饰符？  
* 事件修饰符：  
    .stop  stopPropagation 阻止冒泡  
    .prevent preventDefault 阻止默认行为  
    .self 事件作用在自己身上才触发  
    .once  事件只触发一次  
* 键盘修饰符   
    .enter 回车键  
    .esc 退出键  
* v-model 指令修饰符   
    .lazy 由监听oninput事件转为onchange事件  
    .number 尽量将文本框中的值转为数字，能转就转，不能转就不转  
    .trim 去掉字符串的首尾空格   

### 051.VUE和REACT有什么区别？  
* react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；  
* vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。  

### 052.请说出vue.cli项目中src目录每个文件夹和文件的用法？   
assets文件夹是放静态资源；  
components是放组件；  
router是定义路由相关的配置;  
view视图；  
app.vue是一个应用主组件；  
main.js是入口文件；    


### 054.vue-router单页面应用的切换？
在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。  

### 055.为什么不能用a标签？  
至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。  



### 058.Vue不能检测数组或对象变动问题的解决方法有哪些？  
使用Proxy  
使用$set
改变数组的引用地址，相当于新数组  

### 059.Vue中$attrs使用时需要注意的点  
详细：
包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件——在创建高级别的组件时非常有用。  

使用介绍
从官方介绍我们可以得出 $attrs 应用于父子传值场景下，子组件通过 $attrs 可以访问父组件传过来的所有属性，但需要注意的是如果父组件所传的属性中有在子组件 props 中有过声明，那么该属性不会出现在 $attrs 对象中。   

### 060.vue打包后生成的.map文件有什么作用  
.map文件的生成与否可以在vue.config.js中配置，如下：  
```javascript
module.exports = {
    productionSourceMap: true,
}
```  
当设置为true时，则打包后会生成.map文件，则前端服务把静态资源跑起来的时候，如果有报错信息，错误提示里可以直接定位到某某vue文件哪一行那一列出错了，可以直接点击查看。  
如果设置为false，则打包后不会生成.map文件，则前端服务把静态资源跑起来后，如果有报错信息，则错误提示里直接压缩后的.js文件，无法定位到是哪个vue文件，哪一行出错了。    



### webpack  
熟练掌握Webpack的常用配置,能够自己构建前端环境,并进行项目优化;  
#### 谈谈你对webpack的看法:
webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。

#### webpack的基本功能和工作原理？

代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等
文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等
代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件
自动刷新：监听本地源代码的变化，自动构建，刷新浏览器
代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过
自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。

#### webpack构建过程：
从entry里配置的module开始递归解析entry依赖的所有module
每找到一个module，就会根据配置的loader去找对应的转换规则
对module进行转换后，再解析出当前module依赖的module
这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk
最后webpack会把所有Chunk转换成文件输出
在整个流程中webpack会在恰当的时机执行plugin里定义的逻辑

#### webpack打包原理

将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载

#### 什么是entry,output?

entry 入口，告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js
output 出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist

#### 什么是loader，plugins?

loader是用来告诉webpack如何转换某一类型的文件，并且引入到打包出的文件中。
plugins(插件)作用更大，可以打包优化，资源管理和注入环境变量

#### 什么是bundle,chunk,module?
bundle是webpack打包出来的文件，chunk是webpack在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块



#### npm打包时需要注意哪些？如何利用webpack来更好的构建？


#### 有哪些常见的Loader？他们是解决什么问题的？
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码



webpack默认遵循commonjs规范  module.exports
es6中的规范  export
使用webpack进行打包时有两种模式：
开发模式：
生产模式：要压缩  如果没有插件 就不会压缩 
默认情况下webpack的配置文件叫webpack.config.js，可以通过--config指定webpack的配置文件名

#### 流程：

尝试配置脚手架：可以

#### loader:
css需要两个loader来处理：css-loader   style-loader 
postcss-loader  有动画  目的就是使用浏览器的兼容。
 -webkit-transform: rotate(45deg);
                  transform: rotate(45deg);
mini-css-extract-plugin   以前都是之间引入内部样式，把css专门打包成一个css文件，在index.html文件中引入css  
optimize-css-assets-webpack-plugin   css压缩   
terser-webpack-plugin  css压缩  js不能压缩了  然后由来一个插件  能压缩js
file-loader    是让webpack打包图片
url-loader可以让图片转化base64，也可以让webpack打包图片

webpack 默认情况下 不支持js的高级语法 。  babel转化  npm i @babel/core @babel/preset-env babel-loader --save-dev 
#### plugins
html-webpack-plugin  根据模块生成一个html文件  此时不会在dist文件夹下面 新建index文件了  我需要 在public新建 新建index文件  根据这个模板文件  在内存中生成 index.html  然后自动引入bundle.js
clean-webpack-plugin  去掉没有用到的模块

面试题：
2.1. loader是使webpack拥有加载和解析非js文件的能力
2.2. plugin 可以扩展webpack的功能，使得webpack更加灵活。可以在构建的过程中通过webpack的api改变输出的结果  




## 项目相关  
### 001.适配？  
cube里面自带适配，不需要上面的适配，如果用别的UI库，需要使用REM+Flex适配方案  

### 002.首页白屏怎么解决？　

1，把首页做服务端渲染  SEO   nuxt.js写项目   　　
2，预渲染 数据还没有回来前，先返回的一些死数据，多用在首页面的内部经常不变　　
3，骨架屏  配置 　　

### 003.封装axios？  

### 004.管理状态(数据)  
多个组件需要使用的状态，放到vuex仓库中  
单个组件使用的状态，放到data中 

### 005.来回切换tabbar时，不能重新请求数据  
使用路由钩子  

### 006.来回切换tabbar时，需要加上动画  
使用vue中的动画  

### 007.把数据缓存到内存中，避免再次去请求接口  
使用vue中keep-alive组件  

### 008.有的页面需要缓存，有的不需要怎么办？  
可以在路由处加标识  

### 009.在一个页面中滑倒中间位置，如果切换页面，再切换回去，应该还是处于中间位置怎么办？　
当切换的时候，把位置保存起来，再切换回去的时候，让他还处于那个位置　　

### 010.对于一个app来说，有的页面需要登录后才能看到，有的则不需要怎么办？　
在路由处配标识　　

### 011.怎么验证登录？  
1.验证是否登录过，如果登录过，服务器会返回客户端一个token  
2.客户端把token保存在localStorage中，后面客户再去请求服务器，会在请求拦截那里带上token  
3.如果调用/validata接口时，如果你带着token去访问这个接口，就返回你已登录，如果你没有带上token，就给你返回未登录。    

## 后端相关  
### 01.Mysql与MongoDB的比较  
关系型数据库-MySQL
1、在不同的引擎上有不同的存储方式。
2、查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。
3、开源数据库的份额在不断增加，mysql的份额页在持续增长。
4、缺点就是在海量数据处理的时候效率会显著变慢。

非关系型数据库-MongoDB
非关系型数据库(nosql ),属于文档型数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性，呈现分层的树状数据结构。数据结构由键值(key=>value)对组成。

1、存储方式：虚拟内存+持久化。
2、查询语句：是独特的MongoDB的查询方式。
3、适合场景：事件的记录，内容管理或者博客平台等等。
4、架构特点：可以通过副本集，以及分片来实现高可用。
5、数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。
6、成熟度与广泛度：新兴数据库，成熟度较低，Nosql数据库中最为接近关系型数据库，比较完善的DB之一，适用人群不断在增长。

MongoDB优势与劣势
优势：
1、在适量级的内存的MongoDB的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快。
2、MongoDB的高可用和集群架构拥有十分高的扩展性。
3、在副本集中，当主库遇到问题，无法继续提供服务的时候，副本集将选举一个新的主库继续提供服务。
4、MongoDB的Bson和JSon格式的数据十分适合文档格式的存储与查询。
劣势：
1、 不支持事务操作。MongoDB本身没有自带事务机制，若需要在MongoDB中实现事务机制，需通过一个额外的表，从逻辑上自行实现事务。
2、 应用经验少，由于NoSQL兴起时间短，应用经验相比关系型数据库较少。
3、MongoDB占用空间过大。

### 02.Redis    
redis是一个key-value存储系统，数据存储在内存中，它的优点主要如下：
  1. 支持多种数据类型
    包括set,zset,list,hash,string这五种数据类型，操作非常方便。比如，如果你在做好友系统，查看自己的好友关系，如果采用其他的key-value系统，则必须把对应的好友拼接成字符串，然后在提取好友时，再把value进行解析，而redis则相对简单，直接支持list的存储(采用双向链表或者压缩链表的存储方式)。
  2. 持久化存储
    作为一个内存数据库，最担心的，就是万一机器死机，数据会消失掉。redis使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。
  3. 丰富的特性
    pub/sub，key过期策略，事务，支持多个DB等。
   4. 性能很好
    由于是全内存操作，所以读写性能很好，可以达到10w/s的频率。公司有项目使用redis，目前的访问频率是80w/s，通过适当的部署，线上运行一切ok。

  redis的缺点主要如下：
  1. 由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
  2. 如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
  3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务    



### mongoose使用步骤  
安装，connect  new Schema  创建model  实例化model

### JWT是什么？  
JSON web Token,简称JWT，本质是一个token，是一种紧凑的URL安全方法，用于在网络通信的双方之间传递。一般放在HTTP的headers 参数里面的authorization里面，值的前面加Bearer关键字和空格。  使用 JWT.decode 解析  

## React   

### Hooks原理及使用  

### redux源码？  
createStore  combineReducers  bindActionCreators  applyMiddleware componse
  
  结合react使用：react-redux  redux-thunk  
  
### React生命周期  
初始化阶段、挂载阶段、更新阶段、卸载阶段

初始化阶段：constructor  
挂载阶段 ：componentWillMount  render(必须定义)    componentDidMount(通常在这里发起异步请求，获取数据，使用axios)  
更新阶段：componentWillReceiveProps(props发生变化以及父组件重新渲染时都会触发该生命周期函数)  
                  shouldComponentUpdate(用来判断是否重新渲染，通常在这里优化性能)  
                  componentWillUpdate(组件即将更新时触发)  
                  componentDidUpdate（在组件更新后调用）  
卸载阶段：componentWillUnmount(在组件卸载钱调用)  

v16.4  

static getDerivedStateFromProps（每次更新都会调用）  
getSnapshotBeforeUpdate（用来返回一个快照）  



