---
title: 面试题汇总 
---  
[toc]   

## HTML+CSS面试题
### 001.Flex布局  
 Flex（Flexible Box）布局 称为 "弹性布局"，可以为网页的布局提供最大的灵活性，取代了往常的 浮动（float） 布局，并且任何一个容器都可以设置 Flex 布局。  
 注：设置 Flex 布局后，子元素的 Float 布局将失效     
 [Flex 布局教程](https://juejin.im/post/5cdfc6ade51d4510a9276955)  
 
 ### 002.HTML5+CSS3新特性   
 语义化标签：header、nav、aside、footer、section  
 
 
 ### 003.盒子模型   
 [CSS 盒子模型](https://juejin.im/post/5d2dbecb6fb9a07eff00bbc3)  
 
 ### 004.如何让一个div水平居中？  
 
 ### 005.如何让一个div水平垂直居中？  
 
 ### 006.如何清除浮动？   
 通常在公共的css样式中定义一个清除浮动的类。  
 

``` 
.clearfix{
	clear:both;
}
```

 
 ### 007.css3实现三栏布局，左右固定，中间自适应？  
 >圣杯布局/双飞翼布局  

``` 
 <style>
        * {
            margin: 0;
            padding: 0;
        }
        .middle,
        .left,
        .right {
            position: relative;
            float: left;
            min-height: 130px;
        }
        .container {
            padding: 0 220px 0 200px;
            overflow: hidden;
        }
        .left {
            margin-left: -100%;
            left: -200px;
            width: 200px;
            background: red;
        }
        .right {
            margin-left: -220px;
            right: -220px;
            width: 220px;
            background: green;
        }
        .middle {
            width: 100%;
            background: blue;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class='container'>
        <div class='middle'></div>
        <div class='left'></div>
        <div class='right'></div>
    </div>
</body>
```  
### 008.CSS中 link 和@import 的区别是什么？　
* link属于HTML标签，而@import是CSS提供的  
* 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载  
* import只在IE5以上才能识别，而link是HTML标签，无兼容问题  
* link方式的样式的权重 高于@import的权重.  

### 009.transition和animation的区别？  
Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，
而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。  

### 010.CSS优先级？  

``` 
不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性
	1.属性后面加!import 会覆盖页面内任何位置定义的元素样式
	2.作为style属性写在元素内的样式
	3.id选择器
	4.类选择器
	5.标签选择器
	6.通配符选择器（*）
	7.浏览器自定义或继承
**同一级别：后写的会覆盖先写的**
```   
### 011.使元素消失的方法?  
visibility:hidden、display:none、z-index=-1、opacity：0  
1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发  
2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件  
3.display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉  

### 012.为什么css放在顶部而js写在后面？  
1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了  
2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。  
3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验  

但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面  

### 013.理解BFC吗？  
BFC 即 Block Formatting Contexts (块级格式化上下文)。  
具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。  
通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。  

[理解CSS中的BFC](https://juejin.im/post/5da30040f265da5ba273c47d)  

### 014.Less的使用  
Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性和嵌套写法，使 CSS 更易维护和扩展。   

### 015.回流与重绘  
当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。


重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少


回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:

页面初次渲染
浏览器窗口大小改变
元素尺寸、位置、内容发生改变
元素字体大小变化
添加或者删除可见的 dom 元素
激活 CSS 伪类（例如：:hover）
查询某些属性或调用某些方法

	clientWidth、clientHeight、clientTop、clientLeft
	offsetWidth、offsetHeight、offsetTop、offsetLeft
	scrollWidth、scrollHeight、scrollTop、scrollLeft
	getComputedStyle()
	getBoundingClientRect()
	scrollTo()


回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。
最佳实践:


css

避免使用table布局
将动画效果应用到position属性为absolute或fixed的元素上



javascript

避免频繁操作样式，可汇总后统一 一次修改
尽量使用class进行样式修改
减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入
极限优化时，修改样式可将其display: none后修改
避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住


## Vue面试题  
### 001.vue中的MVVM模式    
即Model-View-ViewModel。  

Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化  

ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。    

DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。  

### 002.v-show与v-if的区别  
条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值  
### 003.指令keep-alive  
在vue-router写着keep-alive，keep-alive的含义：如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令  
### 004.路由嵌套  
路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转。  
router-view本身就是将组件渲染到该位置，  
### 005.指令v-el的使用  
有时候我们想就像使用jquery那样去访问一个元素，此时就**可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。**  

**注：** HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。  

示例：  

``` 
<span v-el:msg>hello</span>
<span v-el:other-msg>world</span>
this.$els.msg.textContent //-> "hello"
this.$els.otherMsg.textContent// -> "world"
this.$els.msg//-><span>hello</span>
```  
### 006.vue中使用事件名  
在vuejs中，我们经常要绑定一些事件，有时候给DOM元素绑定，有时候给组件绑定。绑定事件在HTML中用v-on:click="event"，可以简写为：@click="event"  
### 007.vue.js是什么  
Vue.js（是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。  
Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。  
另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。  
Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件    

### 008.route 和 router 的区别是什么？  
route是“路由信息对象”，包括path,params,hash,query,fullPath,matched,name等路由信息参数。  

router是“路由实例对象”，包括了路由的跳转方法(push、replace)，钩子函数等。  

### 009.mvvm和mvc区别?它和其它框架(jquery)的区别是什么?哪些场景适合?   
mvc和mvvm其实区别并不大。都是一种设计思想。主要就是mvc中Controller演变成mvvm中的viewModel。mvvm主要解决了mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。  

区别：vue数据驱动，通过数据来显示视图层而不是节点操作。  

场景：数据操作比较多的场景，更加便捷  

### 010.vue的优点是什么?  
低耦合。视图(View)可以独立于Model变化和修改，一个ViewModel可以绑定到不同的"View"上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。  

可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。  

独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。  

可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。  

### 000.web缓存  
数据库缓存、服务器端缓存、浏览器端缓存  
* 减少网络带宽消耗  
* 降低服务器压力  
* 减少网络延迟，加快页面打开速度  

### 011.vuex面试相关    

(1)vuex是什么?  

vue框架中状态管理。  

(2)vuex有哪几种属性?  

有五种，分别是 State、 Getters、Mutations 、Actions、 Module  

vuex的State特性  

A、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data  

B、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新  

C、它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中  

vuex的Getters特性  

A、getters 可以对State进行计算操作，它就是Store的计算属性  

B、 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用  

C、 如果一个状态只在一个组件内使用，是可以不用getters  

vuex的Mutations特性  

Actions 类似于 mutations，不同在于：Actions 提交的是 mutations，而不是直接变更状态;Actions 可以包含任意异步操作。  

(3)不用Vuex会带来什么问题?  

可维护性会下降，想修改数据要维护三个地方;   

可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的;  

增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。   

同步异步区别：  
1、流程顺序  
“相应视图—>修改State”拆分成两部分，视图触发Action，Action再触发Mutation。  
2、角色定位  
基于流程顺序，二者扮演不同的角色。  
Mutation：专注于修改State，理论上是修改State的唯一途径。  
Action：业务代码、异步请求。  
3、限制  
角色不同，二者有不同的限制。  
Mutation：必须同步执行。  
Action：可以异步，但不能直接操作State。   

Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。  
每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。**如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难**。

### 012.如何让CSS只在当前组件中起作用  
将当前组件的\<style>修改为\<style scoped>  

### 013.响应式系统简述:  
* 任何一个 Vue Component 都有一个与之对应的 Watcher 实例  
* Vue 的 data 上的属性会被添加 getter 和 setter 属性  
* 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)  
* data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新  

### 014.谈谈你对虚拟DOM的理解？  
首先,我们都知道在前端性能优化的一个秘诀就是尽可能少地操作DOM,不仅仅是DOM相对较慢,更因为频繁变动DOM会造成浏览器的回流或者重回,这些都是性能的杀手,因此我们需要这一层抽象,在patch过程中尽可能地一次性将差异更新到DOM中,这样保证了DOM不会出现性能很差的情况.  

其次,现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能,多人协作的项目中如果review不严格,可能会有开发者写出性能较低的代码,另一方面更重要的是省略手动DOM操作可以大大提高开发效率.  

### 015.Vue 中 key 值的作用？  
当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟DOM。  

### 016.vue 中怎么重置 data?  
使用`Object.assign()`，`vm.$data`可以获取当前状态下的data，`vm.$options.data`可以获取到组件初始化状态下的data。  
`Object.assign(this.$data, this.$options.data())`  

### 017.组件中写 name 选项有什么作用？  
* 项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤  
* DOM 做递归组件时需要调用自身 name  
* vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的  

### 018.为什么需要 nextTick?  
Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改--刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 了。   
$nextTick()是等待dom更新完才会执行的回调  

### 019.vue 首屏加载优化方案  
* 把不常改变的库放到 index.html 中，通过 cdn 引入  
* vue 路由的懒加载  
* 不生成 map 文件（找到 config/index.js，修改为 productionSourceMap: false）  
* vue 组件尽量不要全局引入  
* 使用更轻量级的工具库  
* 开启gzip压缩  
* 首页单独做服务端渲染  

### 020.Vue3.0 有没有过了解？  
关于Vue 3.0，大致说了三个点，第一个是关于提出的新API setup()函数，setup创建组件实例时，在初始组件解析后立即调用。在生命周期方面，它在beforeCreate和created之前被调用（2.x），第二个说了对于Typescript的支持，最后说了关于替换Object.defineProperty为 Proxy 的支持。  
  
详细说了下关于Proxy代替带来的性能上的提升，因为传统的原型链拦截的方法，无法检测对象及数组的一些更新操作，但使用Proxy又带来了浏览器兼容问题。  
### 021.说一下Vue的双向绑定数据的原理  
vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调  

### 022.NextTick 是做什么的?  
$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM  

### 023.Vue 组件 data 为什么必须是函数?  
因为js本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有Vue实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了  

### 024.计算属性computed 和事件 methods 有什么区别  
我们可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的  

不同点：  
* computed: 计算属性是基于它们的依赖进行缓存的,只有在它的相关依赖发生改变时才会重新求值  
* 对于 method ，只要发生重新渲染，method 调用总会执行该函数  

[Vue中watch、computed与methods的联系和区别](https://juejin.im/post/5dc97336e51d456929657092)  
### 025.vue 等单页面应用的优缺点：  
优点：  
* 良好的交互体验  
* 良好的前后端工作分离模式  
* 减轻服务器压力  

缺点：  
* SEO难度较高  
* 前进、后退管理  
* 初次加载耗时多  

### 026.vue生命周期  
vue的生命周期主要分为beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy,destroyed  

创建前后、载入前后、更新前后、销毁前后  
[Vue 生命周期与钩子函数](https://juejin.im/post/5d4591315188257b6546f04e#heading-0)  

### 027.Vue 导航守卫(路由的生命周期)  
全局的  
* router.beforeEach  
* router.beforeResolve  
* router.afterEach  

单个路由独享的  
* beforeEnter  

组件级的  
* beforeRouteEnter  
* beforeRouteUpdate  
* beforeRouteLeave    

[Vue 导航守卫(路由的生命周期)](https://juejin.im/post/5d529884f265da03a1484e56)  
### 028.常见的跨域解决方案  
前端配置vue.config.js  
后端配置  
jsonp（只能解决get）      
>步骤： 1).去创建一个script标签 2).script的src属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据  


[常见的跨域解决方案](https://juejin.im/post/5d52a4fe518825163b090495)  

### 029.什么是webpack及其优点  
* 打包：可以把多个JavaScript文件打包成一个文件，减少服务器压力和下载宽带  
* 转换：把扩展语言转换成为普通的JavaScript，让浏览器顺利运行。  
* 优化：肩负起了优化和提升性能的责任    

### 030.Vue中项目如何优化？  
* data优化  
* SPA首屏加载优化  
* 组件优化  
* 巧妙利用指令v-if(show)，使用v-for要绑定key  
* 使用Object.freeze  
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 服务端渲染SSR  
* 缓存和压缩  
* HTTP优化  


对象层级不要过深，否则性能就会差
不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）
v-if 和 v-show 区分使用场景
computed 和 watch 区分使用场景
v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if
大数据列表和表格性能优化-虚拟列表/虚拟表格
防止内部泄漏，组件销毁后把全局变量和事件销毁
图片懒加载
路由懒加载
第三方插件的按需引入
适当采用 keep-alive 缓存组件
防抖、节流运用
服务端渲染 SSR or 预渲染

### 031.Vue递归组件的使用  
[递归组件](https://juejin.im/post/5d53f8726fb9a06b0b1c6df0)  

### 032.Vue的mode中hash与history的区别  
hash模式重新加载的时候只加载#后面的   
history模式则是整个地址重新加载，不过他可以保存历史记录，方便前进后退    

vue-router 有 3 种路由模式：hash、history、abstract   
* hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；  
* history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；  
* abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.   

### 033.vue中常用的命令  
v-if   v-show区别  
v-for  
v-model  
v-bind  
v-on    

### 034.Vue 的父组件和子组件生命周期钩子函数执行顺序？  
Vue 的父组件和子组件生命周期钩子函数执行顺序？  
* 加载渲染过程  
父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted  
* 子组件更新过程  
父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated  
* 父组件更新过程  
父 beforeUpdate -> 父 updated  
* 销毁过程  
父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed  

### 035.在哪个生命周期内调用异步请求？  
可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：
* 能更快获取到服务端数据，减少页面 loading 时间；  
* ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；  

### 036.组件中 data 为什么是一个函数？  
因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响。  

如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。  

### 037.Vue组件间通信有哪几种方式？  
* props  
* $emit  
* $attr  
* $listener  
* provide  inject  (隔代通信)  
* $parent  $children  
* vuex  

### 038.Proxy 与 Object.defineProperty 优劣对比  
Proxy 的优势如下:  
* Proxy 可以直接监听对象而非属性；  
* Proxy 可以直接监听数组的变化；  
* Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；  
* Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；  
* Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；  
Object.defineProperty 的优势如下:  
* 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。  

### 039.虚拟 DOM 的优缺点？  
优点：  
* 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；  
* 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；  
* 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。  

缺点：  
* 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。    

### 040.虚拟 DOM 实现原理？  
虚拟 DOM 的实现原理主要包括以下 3 部分：  
* 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；  
* diff 算法 — 比较两棵虚拟 DOM 树的差异；  
* pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。  

### 041.vue插槽的使用？  
默认插槽  
具名插槽  
作用域插槽  

### 042.active-class是哪个组件的属性？  
vue-router模块的router-link组件，主要用来控制点击样式问题。  

### 043.怎么定义vue-router的动态路由以及如何获取传过来的动态参数？  
在router目录下的index.js文件中，对path属性加上/:id。
使用route对象的params.id`。

### 044.vue-loader是什么？使用它的用途有哪些？  
vue文件的一个加载器。  
用途：js可以写es6、style样式可以scss或less、template可以加jade等根据官网的定义，  
vue-loader 是 webpack 的一个 loader，用于处理 .vue 文件.  

### 045.为什么避免 v-if 和 v-for 用在一起？  
当Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着v-if将分别重复运行于每个v-for循环中。通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。    

### 046.vue中Class 与 Style 如何动态绑定？  
[Vue Class与Style绑定](https://juejin.im/post/5da1990b51882518fa5a3877)  

### 047.怎样理解 Vue 的单向数据流？  
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。  

额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。    

### 048.直接给一个数组项赋值，Vue 能检测到变化吗？  
由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：  
* 当你利用索引直接设置一个数组项时，例如：vm.items\[indexOfItem] = newValue  
* 当你修改数组的长度时，例如：vm.items.length = newLength  

### 049.vue.js的核心是什么？  
* 数据驱动（响应式）：data中的数据变了，视图才会变  
* 组件化：拆组装，目的在于重用，方便，脏活累活一次干完，之后就轻松了     

### 050.vue的常用修饰符？  
* 事件修饰符：  
    .stop  stopPropagation 阻止冒泡  
    .prevent preventDefault 阻止默认行为  
    .self 事件作用在自己身上才触发  
    .once  事件只触发一次  
* 键盘修饰符   
    .enter 回车键  
    .esc 退出键  
* v-model 指令修饰符   
    .lazy 由监听oninput事件转为onchange事件  
    .number 尽量将文本框中的值转为数字，能转就转，不能转就不转  
    .trim 去掉字符串的首尾空格   

### 051.VUE和REACT有什么区别？  
* react整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在react中，是单向数据流；  
* vue的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立Watcher来监听，当属性变化的时候，响应式的更新对应的虚拟dom。  

### 052.请说出vue.cli项目中src目录每个文件夹和文件的用法？   
assets文件夹是放静态资源；  
components是放组件；  
router是定义路由相关的配置;  
view视图；  
app.vue是一个应用主组件；  
main.js是入口文件；    

### 053.单页面应用和多页面应用区别及优缺点？  
单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。  

多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新  

单页面的优点：  
用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小  
前后端分离  
页面效果会比较炫酷（比如切换页面内容时的专场动画）   

单页面缺点：  
初次加载时耗时多  
页面复杂度提高很多  
导航不可用，如果一定要导航需要自行实现前进、后退。

### 054.vue-router单页面应用的切换？
在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。路由模块的本质 就是建立起url和页面之间的映射关系。  

### 055.为什么不能用a标签？  
至于为啥不能用a标签，这是因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以你写的标签是不起作用的，必须使用vue-router来进行管理。  

### 057.vue两个核心点是什么？  
数据驱动  
组件系统  

### 058.Vue不能检测数组或对象变动问题的解决方法有哪些？  
使用Proxy  
使用$set
改变数组的引用地址，相当于新数组  

### 059.Vue中$attrs使用时需要注意的点  
详细：
包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件——在创建高级别的组件时非常有用。  

使用介绍
从官方介绍我们可以得出 $attrs 应用于父子传值场景下，子组件通过 $attrs 可以访问父组件传过来的所有属性，但需要注意的是如果父组件所传的属性中有在子组件 props 中有过声明，那么该属性不会出现在 $attrs 对象中。   

### 060.vue打包后生成的.map文件有什么作用  
.map文件的生成与否可以在vue.config.js中配置，如下：  
```javascript
module.exports = {
    productionSourceMap: true,
}
```  
当设置为true时，则打包后会生成.map文件，则前端服务把静态资源跑起来的时候，如果有报错信息，错误提示里可以直接定位到某某vue文件哪一行那一列出错了，可以直接点击查看。  
如果设置为false，则打包后不会生成.map文件，则前端服务把静态资源跑起来后，如果有报错信息，则错误提示里直接压缩后的.js文件，无法定位到是哪个vue文件，哪一行出错了。    

### 061.简要说明Vue 2.x的全链路运作机制?  
初始化以及挂载init, mount  
再进行模板编译compile,将template编译为渲染函数render function  
执行render function生成Virtual DOM, render function => VNode tree   
再进行响应式依赖收集, render function=> getter,setter => Watcher.update => patch。以及使用队列进行异步更新的策略。  
最后通过diff算法后进行patch更新视图  


## HTTP面试题  
### 001.网络七层模型    
[网络七层模型（四层模型）及其区别](https://juejin.im/post/5d787bf4f265da03f04cf7b2)  
### 002.三次握手，四次挥手  
[TCP 三次握手 与 四次挥手](https://juejin.im/post/5d287c8651882536124055da)  
### 003.从输入一个网址到看到一张网页，经历了什么？  
[从输入一个网址到浏览器显示页面的全过程详细分析](https://juejin.im/post/5d286b3e6fb9a07f0c46af61)  
### 004.HTTP的请求与响应  
* 请求：  
  * 请求行，GET/HTTP/1.1  
  * 请求头，非常多  
  * 请求正文，扔给服务器的数据  
* 响应：  
  * 响应行，HTTP/1.1 200 OK  
  * 响应头，非常多  
  * 响应正文，服务器扔给客户端的数据  

### 005.HTTP状态码  
* 1xx  
  * 101（双向通信）  
* 2xx  
  * 200（成功）  
  * 204（没有响应体）  
  * 206（断点续传）  
* 3xx  
  * 301（永久重定向）  
  * 302（临时重定向）  
  * 304（缓存）  
* 4xx  
  * 401（没有权限）  
  * 403（登陆了没有权限）  
  * 404（找不到对应的资源）  
  * 405（请求方法不存在，不支持）  
* 5xx  
  * 502（负载均衡）  

### 006.HTTP中的请求方法（8种）  
[HTTP协议简介](https://juejin.im/post/5d288ac251882557e1178f89)  
### 007.HTTP优化策略（博客）  
压缩和缓存    
[HTTP前端性能优化(压缩与缓存)](https://juejin.im/post/5d78cf2a5188251abc7ee0b1)  
### 008.HTTP中的头（重点）  
* 请求头：  
  * `accept-encoding` 告诉服务器，我接收的数据支持压缩格式  
  * `if-modified-since` 对比缓存  修改时间   
  *  `if-none-match` 摘要缓存  和`Etag`配对使用的  
  *  `user-agent` 不同设备自动带上这个头   判断什么样的设备，重定向到不同项目  
* 响应头：  
  * `Content-Type`  告诉浏览器  我给你的内容的类型  
  * `Content-Encoding`  告诉浏览器  我给你的内容的压缩格式   
  * `Cache-Control` 强制缓存  告诉浏览器，你多长时间之间，不要来访问我  
  * `Expires`  强缓   告诉浏览器，你多长时间之间，不要来访问我  
  * `Last-Modified` 对比缓存 和 `if-modified-since` 配对使用  
  * `Etag`   根据摘要做缓存   和 `if-none-match` 配对使用  
  *  `Lotaion`  重定向到 某个地方    

### 009.HTTP中的代理  
### 010.http和https有什么不同？  
* https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密  
* http：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少  

### 011.localStorage, sessionStorage, cookie, session有什么区别？  
* localStorage 不能跨域存取   最大存5M   超过5M的数据就会丢失   在发送请求时，不会带上localStorage  
* sessionStorage 当浏览器关闭时，里面的数据就丢失  
* cookie 服务器种植的，每次请求都会带上cookie，不安全，解决无状态问题，最多4K，浪费流量  
* session 基于cookie  保存在服务器（内存，入库） 相对安全  

前后端分离（前端调后端api接口）开发的：cookie，**主流：session 或 JWT**      

### 012.从输入一个网址到浏览器显示页面的全过程？  
1.DNS解析，找到IP地址  
2.根据IP地址，找到对应的服务器  
3.建立TCP连接(里面有个 三次握手)  
4.连接建立后，发出HTTP请求  
5.服务器根据请求作出HTTP响应  
6.浏览器得到响应内容，进行解析与渲染，并显示  
7.断开连接(四次挥手)    

[从输入一个网址到浏览器显示页面的全过程详细分析](https://juejin.im/post/5d286b3e6fb9a07f0c46af61)    

### 013.简单说一下三次握手与四次挥手，为什么一个三次，一个四次？  
[TCP 三次握手 与 四次挥手](https://juejin.im/post/5d287c8651882536124055da)  


### 014.说一下web缓存？  
1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本  
2.缓存的好处  
    （1）减少不必要的请求  
    （2）降低服务器的压力，减少服务器的消耗  
    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）  

### 015.常见的web安全及防护原理？  
* sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。  
* XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。  
* CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求  

**设置Cookie时如何防止XSS攻击？**  
在服务器端设置cookie的时候设置http-only,这样就可
以防止用户通过JS获取cookie。对cookie的读写或发送
一般有如下字段进行设置:  
 * http-only:只允许http或https请求读取cookie, JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.  
 * secure-only:只允许https请求读取,发送请求时自动发送cookie  
 * host-only:只允许主机域名与domain设置完成一致的网站才能访问该cookie。 
 
 设置Cookie,可以防止攻击者拿到正常用户的Cookie冒充身份非法调用网站接口。   

### 016.正向代理与反向代理的区别  
代理可以分为正向代理和反向代理两种。  

正向代理需要客户端来配置，一般来说我们会通过浏览器或者操作系统提供的工具或者界面来配置。这个时候，代理对客户端不是透明的，客户端需要知道代理的地址并且手动配置。配置了代理，浏览器在发送请求的时候会对报文做特殊的修改。  

反向代理对客户端是透明的，也就是说客户端一般不知道代理的存在，认为自己是直接和服务器通信。我们大部分访问的网站就是反向代理服务器，反向代理服务器会转发到真正的服务器，一般在反向代理这一层实现负载均衡和高可用的功能。而且这里也可以看到，客户端是不会知道真正服务器端的 ip 地址和端口的，这在一定程度上起到了安全保护的作用。




## JS面试题    
### JS中的方法（重中之重）   
https://juejin.im/post/5d3bd7c9e51d45777a126290  
### 001.Promise原理(\*\*)？  

答：看代码，参考：https://juejin.im/post/5b2f02cd5188252b937548ab

### 002.then可以链式调用，多个then时，如何走到下一个then的失败回调？   

答：1.返回一个失败的promise。2.抛出一个错误(throw new Error())  

### 003.then可以链式调用，多个then时，如何终止下一个then的调用？  

答：返回一个处于pending(等待态)状态的promise    
	
### 004.js的异步解决方案有哪些(\*\*)？ 

答：  
* 回调函数（嵌套，回调地狱，不优雅）  
* Promise    
* Generator+co （co可以解决promise嵌套问题，generator+promise(promise嵌套问题)）  
* async+await：是Generator的语法糖  

### 005.把一个伪数组变成真实的数组？  

答：  
* [...obj]，需要保证obj是可迭代的  
* Array.from不需要保证obj是否迭代，内部会使它可迭代  

### 006.使用过ES6中哪些新语法(\*\* 熟练使用ES6语法)？  

答：  
* 结构赋值 [] {}    
* 展开运算符（...args）(考察深拷贝，浅拷贝)    
* Set：常用于数组去重    
* Map：里面存储唯一的值  
>深拷贝实现的一种方式：JSON.parse(JSON.strinfy(obj));    

[ES6 新增内容总结](https://juejin.im/post/5d3eb1b6f265da03c23eacc2)  

### 007.实现深拷贝（重点）浅拷贝？   
[理解JS中的浅拷贝与深拷贝](https://juejin.im/post/5da1c7cee51d45784603adbc#heading-8)  

``` 
function deepClone(source) {
    const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象
    for (let keys in source) { // 遍历目标
        if (source.hasOwnProperty(keys)) {
            if (source[keys] && typeof source[keys] === 'object') { // 如果值是对象，就递归一下
                targetObj[keys] = source[keys].constructor === Array ? [] : {};
                targetObj[keys] = deepClone(source[keys]);
            } else { // 如果不是，就直接赋值
                targetObj[keys] = source[keys];
            }
        }
    }
    return targetObj;
}

var str1 = {
    arr: [1, 2, 3],
    obj: {
        key: 'value'
    },
    fn: function () {
        return 1;
    }
};
var str3 = deepClone(str1);

console.log(str3 === str1); // false
console.log(str3.obj === str1.obj); // false
console.log(str3.fn === str1.fn); // true
```

### 008.求数组的交集、并集、差集？  

答：  

``` 
//-----------------------------------------并集
// let arr1 = [1, 2, 3, 4]
// let arr2 = [3, 4, 5, 6]

//并集
// function union(arr1, arr2) {
//     // let s1 = new Set(arr1)
//     // let s2 = new Set(arr2)
//     // let s = new Set([...s1,...s2])
//     // return [...s]

//     let s = new Set([...arr1,...arr2])
//     return [...s]
// }

// console.log(union(arr1,arr2));  //[ 1, 2, 3, 4, 5, 6 ]

//-----------------------------------------交集
// let arr1 = [1, 2, 3, 4]
// let arr2 = [3, 4, 5, 6]

// //交集
// function intersection(arr1,arr2){
//     let s1 = new Set(arr1)
//     let s2 = new Set(arr2)
//     return [...s1].filter(item=>{
//         return s2.has(item)
//     })
// }

// console.log(intersection(arr1,arr2))    //[ 3, 4 ]

//-----------------------------------------差集
// let arr1 = [1, 2, 3, 4]
// let arr2 = [3, 4, 5, 6]

// function difference(arr1,arr2){
//     let s1 = new Set(arr1)
//     let s2 = new Set(arr2)
//     return [...s1].filter(item=>{
//         return !s2.has(item)
//     })
// }

// console.log(difference(arr1,arr2))      //[ 1, 2 ]
```    

### 009.ES6中的模块化？  
答：  https://juejin.im/post/5d3eb1b6f265da03c23eacc2#heading-44  

ES6 的模块化分为导出（export） @与导入（import）两个模块。  

as 的用法  

### 010.模块化的发展流程？    

### 011.JS中的闭包    
什么是闭包  

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。  

1. 优点
可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用
避免变量污染全局
把变量存到独立的作用域，作为私有成员存在
2. 缺点
对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏
对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度
可能获取到意外的值(captured value)

### 012.浏览器事件环 (宏、微任务)  
[JS(浏览器)事件环 (宏、微任务)](https://juejin.im/post/5d552275e51d456201486e24)    

### 013.ES6新增了哪些内容，简单说一下  
[ES6 新增内容总结](https://juejin.im/post/5d3eb1b6f265da03c23eacc2)  

### 014.对JS原型和原型链的理解？  
[JavaScript 原型 与 原型链](https://juejin.im/post/5d3c446de51d45108c59a64f)  

### 015.对JS作用域和作用域链的理解？    
[JavaScript 作用域 与 作用域链](https://juejin.im/post/5d3c3cee6fb9a07eb55fa48f)  

### 016.JS中new究竟做了什么？  
1.创建对象  
2.绑定this
3.链接到原型  
4.返回对象  
[JS中 new究竟做了什么？](https://juejin.im/post/5d382ecf51882557af272449)  

### 017.JS中this到底指向谁？怎么改变this指向？  
**谁调用了包含this的方法，那么this就指向谁**  
[JS中的 this 到底指向谁？](https://juejin.im/post/5d3812cfe51d45773e418b63)  

改变this，可以用call、apply、bind，他们之间的区别？  
[JS中改变this的指向 call、apply 和 bind 的区别](https://juejin.im/post/5d37a67fe51d45778f076e10)      

### 018.TS主要是干什么的？  
简单地说，TS就是增加了重要的类型检测机制，添加了很多类型，可以用来写大型项目。  
布尔值、数字、字符串、数组、元组、枚举、any、void、null、undefined、never、object、类型断言  

### 018.JS常见的设计模式  
* 构造函数设计模式  
* 原型模式  
* 模块设计模式  
* 单例模式  
* 工厂模式  
* 观察者模式  
* 命令模式  
* 装饰模式  
* MVC模式  
* MVVM模式  

### 019.JS阻止冒泡和取消默认事件  
防止冒泡和捕获：  
w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true  
  
stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。  

取消默认事件：  
w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;  

总结使用方法：
当需要停止冒泡行为时，可以使用  

``` 
function stopBubble(e) { 
//如果提供了事件对象，则这是一个非IE浏览器 
if ( e && e.stopPropagation ) 
    //因此它支持W3C的stopPropagation()方法 
    e.stopPropagation(); 
else 
    //否则，我们需要使用IE的方式来取消事件冒泡 
    window.event.cancelBubble = true; 
}
```  
当需要阻止默认行为时，可以使用  

``` 
//阻止浏览器的默认行为 
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
    return false; 
}
```  
### 20.JS是如何运行的？  
答: Js代码 ——>解析成AST (期间伴随词法分析、语法分析)——>生成字节码(V8)——>生成机器码(编译器)


## 项目相关  
### 001.适配？  
cube里面自带适配，不需要上面的适配，如果用别的UI库，需要使用REM+Flex适配方案  

### 002.首页白屏怎么解决？　

1，把首页做服务端渲染  SEO   nuxt.js写项目   　　
2，预渲染 数据还没有回来前，先返回的一些死数据，多用在首页面的内部经常不变　　
3，骨架屏  配置 　　

### 003.封装axios？  

### 004.管理状态(数据)  
多个组件需要使用的状态，放到vuex仓库中  
单个组件使用的状态，放到data中 

### 005.来回切换tabbar时，不能重新请求数据  
使用路由钩子  

### 006.来回切换tabbar时，需要加上动画  
使用vue中的动画  

### 007.把数据缓存到内存中，避免再次去请求接口  
使用vue中keep-alive组件  

### 008.有的页面需要缓存，有的不需要怎么办？  
可以在路由处加标识  

### 009.在一个页面中滑倒中间位置，如果切换页面，再切换回去，应该还是处于中间位置怎么办？　
当切换的时候，把位置保存起来，再切换回去的时候，让他还处于那个位置　　

### 010.对于一个app来说，有的页面需要登录后才能看到，有的则不需要怎么办？　
在路由处配标识　　

### 011.怎么验证登录？  
1.验证是否登录过，如果登录过，服务器会返回客户端一个token  
2.客户端把token保存在localStorage中，后面客户再去请求服务器，会在请求拦截那里带上token  
3.如果调用/validata接口时，如果你带着token去访问这个接口，就返回你已登录，如果你没有带上token，就给你返回未登录。    

## 后端相关  
### 01.Mysql与MongoDB的比较  
关系型数据库-MySQL
1、在不同的引擎上有不同的存储方式。
2、查询语句是使用传统的sql语句，拥有较为成熟的体系，成熟度很高。
3、开源数据库的份额在不断增加，mysql的份额页在持续增长。
4、缺点就是在海量数据处理的时候效率会显著变慢。

非关系型数据库-MongoDB
非关系型数据库(nosql ),属于文档型数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。这些数据具备自述性，呈现分层的树状数据结构。数据结构由键值(key=>value)对组成。

1、存储方式：虚拟内存+持久化。
2、查询语句：是独特的MongoDB的查询方式。
3、适合场景：事件的记录，内容管理或者博客平台等等。
4、架构特点：可以通过副本集，以及分片来实现高可用。
5、数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存储在物理内存中，从而达到高速读写。
6、成熟度与广泛度：新兴数据库，成熟度较低，Nosql数据库中最为接近关系型数据库，比较完善的DB之一，适用人群不断在增长。

MongoDB优势与劣势
优势：
1、在适量级的内存的MongoDB的性能是非常迅速的，它将热数据存储在物理内存中，使得热数据的读写变得十分快。
2、MongoDB的高可用和集群架构拥有十分高的扩展性。
3、在副本集中，当主库遇到问题，无法继续提供服务的时候，副本集将选举一个新的主库继续提供服务。
4、MongoDB的Bson和JSon格式的数据十分适合文档格式的存储与查询。
劣势：
1、 不支持事务操作。MongoDB本身没有自带事务机制，若需要在MongoDB中实现事务机制，需通过一个额外的表，从逻辑上自行实现事务。
2、 应用经验少，由于NoSQL兴起时间短，应用经验相比关系型数据库较少。
3、MongoDB占用空间过大。

### 02.Redis    
redis是一个key-value存储系统，数据存储在内存中，它的优点主要如下：
  1. 支持多种数据类型
    包括set,zset,list,hash,string这五种数据类型，操作非常方便。比如，如果你在做好友系统，查看自己的好友关系，如果采用其他的key-value系统，则必须把对应的好友拼接成字符串，然后在提取好友时，再把value进行解析，而redis则相对简单，直接支持list的存储(采用双向链表或者压缩链表的存储方式)。
  2. 持久化存储
    作为一个内存数据库，最担心的，就是万一机器死机，数据会消失掉。redis使用rdb和aof做数据的持久化存储。主从数据同时，生成rdb文件，并利用缓冲区添加新的数据更新操作做对应的同步。
  3. 丰富的特性
    pub/sub，key过期策略，事务，支持多个DB等。
   4. 性能很好
    由于是全内存操作，所以读写性能很好，可以达到10w/s的频率。公司有项目使用redis，目前的访问频率是80w/s，通过适当的部署，线上运行一切ok。

  redis的缺点主要如下：
  1. 由于是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然redis本身有key过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。
  2. 如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。
  3. 修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，redis不能提供服务    

### 怎么向面试官提问题？
团队成员有多少人？大家怎么分工？目前团队的核心工作是哪些？  

如果我来到公司之后，每天的日常工作是什么？  

如何评估员工在试用期间的表现？考核标准是什么？  

贵公司与竞争对手不同在什么方面？  

您为什么从众多简历里选中我来参加面试？  

在这里工作您最享受什么？  

最成功的团队成员与其他普通员工之间有什么不同？  

### 这个项目你遇到了哪个比较棘手的问题？  至少两个    
问题：验证   

### 用什么客服？  
七鱼---收费的  
### cube-ui怎么用？  
cube-ui什么时候能使用？两年前可以使用吗？如果使用别的适配方案呢？不使用cube-ui的  

### mongoose使用步骤  
安装，connect  new Schema  创建model  实例化model

### JWT是什么？  
JSON web Token,简称JWT，本质是一个token，是一种紧凑的URL安全方法，用于在网络通信的双方之间传递。一般放在HTTP的headers 参数里面的authorization里面，值的前面加Bearer关键字和空格。  使用 JWT.decode 解析  

### redux源码？  
createStore  combineReducers  bindActionCreators  applyMiddleware componse
  
  结合react使用：react-redux  redux-thunk  
  
### React生命周期  
初始化阶段、挂载阶段、更新阶段、卸载阶段

初始化阶段：constructor  
挂载阶段 ：componentWillMount  render(必须定义)    componentDidMount(通常在这里发起异步请求，获取数据，使用axios)  
更新阶段：componentWillReceiveProps(props发生变化以及父组件重新渲染时都会触发该生命周期函数)  
                  shouldComponentUpdate(用来判断是否重新渲染，通常在这里优化性能)  
                  componentWillUpdate(组件即将更新时触发)  
                  componentDidUpdate（在组件更新后调用）  
卸载阶段：componentWillUnmount(在组件卸载钱调用)  

v16.4  

static getDerivedStateFromProps（每次更新都会调用）  
getSnapshotBeforeUpdate（用来返回一个快照）  

### webpack  
熟练掌握Webpack的常用配置,能够自己构建前端环境,并进行项目优化;  
#### 谈谈你对webpack的看法:
webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。对于不同类型的依赖，webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。

#### webpack的基本功能和工作原理？

代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等
文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等
代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载
模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件
自动刷新：监听本地源代码的变化，自动构建，刷新浏览器
代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过
自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。

#### webpack构建过程：
从entry里配置的module开始递归解析entry依赖的所有module
每找到一个module，就会根据配置的loader去找对应的转换规则
对module进行转换后，再解析出当前module依赖的module
这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk
最后webpack会把所有Chunk转换成文件输出
在整个流程中webpack会在恰当的时机执行plugin里定义的逻辑

#### webpack打包原理

将所有依赖打包成一个bundle.js，通过代码分割成单元片段按需加载

#### 什么是entry,output?

entry 入口，告诉webpack要使用哪个模块作为构建项目的起点，默认为./src/index.js
output 出口，告诉webpack在哪里输出它打包好的代码以及如何命名，默认为./dist

#### 什么是loader，plugins?

loader是用来告诉webpack如何转换某一类型的文件，并且引入到打包出的文件中。
plugins(插件)作用更大，可以打包优化，资源管理和注入环境变量

#### 什么是bundle,chunk,module?
bundle是webpack打包出来的文件，chunk是webpack在进行模块的依赖分析的时候，代码分割出来的代码块。module是开发中的单个模块



#### npm打包时需要注意哪些？如何利用webpack来更好的构建？


#### 有哪些常见的Loader？他们是解决什么问题的？
file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去source-map-loader：加载额外的 Source Map 文件，以方便断点调试image-loader：加载并且压缩图片文件babel-loader：把 ES6 转换成 ES5css-loader：加载 CSS，支持模块化、压缩、文件导入等特性style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。eslint-loader：通过 ESLint 检查 JavaScript 代码



webpack默认遵循commonjs规范  module.exports
es6中的规范  export
使用webpack进行打包时有两种模式：
开发模式：
生产模式：要压缩  如果没有插件 就不会压缩 
默认情况下webpack的配置文件叫webpack.config.js，可以通过--config指定webpack的配置文件名

#### 流程：

尝试配置脚手架：可以

#### loader:
css需要两个loader来处理：css-loader   style-loader 
postcss-loader  有动画  目的就是使用浏览器的兼容。
 -webkit-transform: rotate(45deg);
                  transform: rotate(45deg);
mini-css-extract-plugin   以前都是之间引入内部样式，把css专门打包成一个css文件，在index.html文件中引入css  
optimize-css-assets-webpack-plugin   css压缩   
terser-webpack-plugin  css压缩  js不能压缩了  然后由来一个插件  能压缩js
file-loader    是让webpack打包图片
url-loader可以让图片转化base64，也可以让webpack打包图片

webpack 默认情况下 不支持js的高级语法 。  babel转化  npm i @babel/core @babel/preset-env babel-loader --save-dev 
#### plugins
html-webpack-plugin  根据模块生成一个html文件  此时不会在dist文件夹下面 新建index文件了  我需要 在public新建 新建index文件  根据这个模板文件  在内存中生成 index.html  然后自动引入bundle.js
clean-webpack-plugin  去掉没有用到的模块

面试题：
2.1. loader是使webpack拥有加载和解析非js文件的能力
2.2. plugin 可以扩展webpack的功能，使得webpack更加灵活。可以在构建的过程中通过webpack的api改变输出的结果  



