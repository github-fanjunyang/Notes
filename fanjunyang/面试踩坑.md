[toc]  

# this在jquery中的使用，this关键字  
this表示JS的DOM对象
$(this)表示把DOM对象转换为Jquery对象  

# jquery的优点  
1.轻量  
2.丰富的DOM选择器  
3.链式表达式  
4.事件、样式、动画支持  
5.跨浏览器兼容  
6.可扩展性  

# delete 和 Vue.delete区别？  
delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。  
Vue.delete 直接删除了数组 改变了数组的键值。  

# axios优点  
1.简单易用  
2.兼容性好  
3.通用性好  
4.稳定  
5.提供了一些并发请求  
6.支持拦截请求和响应  
7.安全，支持防御  
8.支持Promise  

# MVC、MVP、MVVM区别？  
## MVC  
实线表示调用，虚线表示通知   

![MVC1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/xx.png)    

Controller 是 MVC 中的 C，指控制层，在 Controller 层会接收用户所有的操作，并根据写好的代码进行相应的操作——触发 Model 层，或者触发 View 层，抑或是两者都触发。  
需要注意：Controller 层触发 View 层时，并不会更新 View 层中的数据，View 层中的数据是通过监听 Model 层数据变化而自动更新的，与 Controller 层无关。  

![MVC2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVC2.png)

## MVP  

![MVP1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP1.png)

在 MVC 框架中，View 层可以通过访问 Model 层来更新，但在 MVP 框架中，View 层不能再直接访问 Model 层，必须通过 Presenter 层提供的接口，然后 Presenter 层再去访问 Model 层。

这看起来有点多此一举，但用处着实不小，主要有两点：  
* 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。  
* 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。  

![MVP2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP2.png)  

View 层与 Model 层确实互不干涉，View 层也自由了很多。但还是有问题，因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。  
而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。  

## MVVM   

![MVVM1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM1.png)  

可能感觉 MVVM 的框架图与 MVP 的框架图相似，确实如此，两者都是从 View 层开始触发用户的操作，之后经过第三层，最后到达 Model 层。但是关键问题是这第三层的内容， ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，两者孰优孰劣不言而喻。   

![MVVM2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM2.png)  


# created和mounted的区别?  
created中data已经挂载,DOM还没挂载  

mounted中调用方法改变data数据可能引起二次渲染  
mounted中data和DOM都挂载了   

# 性能优化  
* data优化（对象层级不要过深，不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据））  
* 巧妙利用指令v-if(show)，使用v-for要绑定key   
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 缓存和压缩  
* HTTP优化  
* computed 和 watch 区分使用场景
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染   
* 文件压缩，减小资源大小  
* 小图片转base64，减少请求  
* 雪碧图，减少请求  
* 渲染优化（重绘、回流）  
* 减少cookie的使用，减少请求携带大小  

# `==`与`===`的区别，是否`===`就完全靠谱？  
不一定靠谱，例如 `0 === -0`就为true，`NaN === NaN`为false，判断两个变量是否完全相等可以使用ES6新增的API，`Object.is(0, -0)`，就可以准确区分  

# HTTP如何实现长连接?  
* HTTP分为长连接和短连接,其实本质上说的是TCP的长短连接。TCP连接是一个双向的通道,它是可以保持一段时间不关闭的,因此TCP连接才有真正的长连接和短连接这一个说法。
* 长连接是指的是TCP连接,而不是HTTP连接。
* TCP长连接可以复用一个TCP连接来发起多次HTTP请求,这样可以减少资源消耗,比如一次请求HTML,短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接,在响应头设置Connection为keep-alive, HTTP1.1默认是长连接,而HTTP 1.0协议也支持长连接，但是默认是关闭的。    

# POST和GET有哪些区别?
* 请求参数: GET把参数包含在URL中,用&连接起来; POST通过request body传递参数。
* 请求缓存: GET请求会被主动Cache,而POST请求不会，除非手动设置。
* 收藏为书签: GET请求支持收藏为书签, POST请求不支持。
* 安全性: POST比GET安全, GET请求在浏览器回退时是无害的,而POST会再次请求。
* 历史记录: GET请求参数会被完整保留在浏览历史记录里,而POST中的参数不会被保留。
* 编码方式: GET请求只能进行ur编码,而POST支持多种编码方式。
* 参数数据类型: GET只接受ASCIl字符,而POST没有限制数据类型。
* 数据包: GET产生一个TCP数据包; POST可能产生两个TCP数据包。

# Node如果创建一个子进程？  



