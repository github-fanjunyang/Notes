[toc]  


# delete 和 Vue.delete区别？  
delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。  
Vue.delete 直接删除了数组 改变了数组的键值。  

# axios优点  
1.简单易用  
2.兼容性好  
3.通用性好  
4.稳定  
5.提供了一些并发请求  
6.支持拦截请求和响应  
7.安全，支持防御  
8.支持Promise  

# MVC、MVP、MVVM区别？  
## MVC  
实线表示调用，虚线表示通知   

![MVC1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/xx.png)    

Controller 是 MVC 中的 C，指控制层，在 Controller 层会接收用户所有的操作，并根据写好的代码进行相应的操作——触发 Model 层，或者触发 View 层，抑或是两者都触发。  
需要注意：Controller 层触发 View 层时，并不会更新 View 层中的数据，View 层中的数据是通过监听 Model 层数据变化而自动更新的，与 Controller 层无关。  

![MVC2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVC2.png)

## MVP  

![MVP1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP1.png)

在 MVC 框架中，View 层可以通过访问 Model 层来更新，但在 MVP 框架中，View 层不能再直接访问 Model 层，必须通过 Presenter 层提供的接口，然后 Presenter 层再去访问 Model 层。

这看起来有点多此一举，但用处着实不小，主要有两点：  
* 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。  
* 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。  

![MVP2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP2.png)  

View 层与 Model 层确实互不干涉，View 层也自由了很多。但还是有问题，因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。  
而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。  

## MVVM   

![MVVM1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM1.png)  

可能感觉 MVVM 的框架图与 MVP 的框架图相似，确实如此，两者都是从 View 层开始触发用户的操作，之后经过第三层，最后到达 Model 层。但是关键问题是这第三层的内容， ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，两者孰优孰劣不言而喻。   

![MVVM2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM2.png)  


# created和mounted的区别?  
created中data已经挂载,DOM还没挂载  

mounted中调用方法改变data数据可能引起二次渲染  
mounted中data和DOM都挂载了   

# 性能优化  
* data优化（对象层级不要过深，不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据））  
* 巧妙利用指令v-if(show)，使用v-for要绑定key   
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 缓存和压缩  
* HTTP优化  
* computed 和 watch 区分使用场景
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染   
* 文件压缩，减小资源大小  
* 小图片转base64，减少请求  
* 雪碧图，减少请求  
* 渲染优化（重绘、回流）  
* 减少cookie的使用，减少请求携带大小  



# Node如何创建一个子进程？  

![Node1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Node1.png)  

# React的hooks执行原理？  


# 简单介绍下Koa  
NodeJS本质上就是使用JS语言写的解析器，NodeJS给了JS在服务器端的运行环境  

Koa 是一个使用 Node.js 的 web 开发框架，其核心是反复使用的洋葱模型中间件，通过中间件解决 web 开发中的 http 处理、业务逻辑实现  

**介绍下洋葱模型**     

[Express和Koa分析](https://juejin.cn/post/6844903922428035085)  

# Node是如何处理高并发的？  
* eventproxy  
* async.queue  
* async.mapLimit  


# 介绍下Vue插件的使用,怎么自定义插件/指令,Vue.use()怎么使用？  
Vue.use方法主要做了如下的事：  
* 检查插件是否安装，如果安装了就不再安装  
* 如果没有安装，那么调用插件的install方法，并传入Vue实例    

Vue 自定义指令有全局注册和局部注册两种方式。  
注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。   

指令定义函数提供了几个钩子函数（可选）：
* bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。
* inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。
* update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。
* componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。
* unbind: 只调用一次， 指令与元素解绑时调用。  

![Vue.use](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Vue.use.png)   



# 不用all方法实现一个Promise.all功能    

``` 
function promiseAll(iterable) {
    const array = [...iterable]
    const result = []
    return new Promise((reslove, reject) => {
        for(let i = 0; i < array.length; i++) {
            Promise.resolve(array[i]).then(res => {
                result.push(res)
                result.length === array.length && reslove(result)
            }).catch(reason => {
                reject(reason)
            })
        }
    })
}
```


# 如果后端返回数据量比较大怎么办？  
从后端的角度：
* 尽量预处理并规整返回的数据：给到合理的数据格式以及需要用作展示的数据，尽量减轻前端的数据处理逻辑。 

从前端的角度：
* 数据传输大，意味着会有较长的网络传输时间，那么最好的方式就是要进行数据缓存。
* 从另外一个角度，可以使用 NodeJS 中间层的方式，不经过浏览器先行请求接口数据并将数据预处理，前端通过调用中间层暴露的接口来调用，浏览器获得的即为中间层处理后的数据，前端可以减轻大量的逻辑处理，拿到的数据可以直接使用，也可以提高页面渲染效率。  
* 当然，渲染是浏览器的事，但是最好也做到按需加载提高性能。      
* 用虚拟列表


# Node端如何做实时监控、如何保存日志？      

目前采用PM2做Node进程监控和管理，使用PM2的配置来保存日志输出  

可以使用[log.io](https://github.com/NarrativeScience/log.io)来做服务的实时监控  

# Redux中都有什么方法？有什么中间件来处理Redux?    

[一篇足矣](https://juejin.cn/post/6844903983299952648)  

# Vue中data/computed相关问题  
> data中有属性A、B、C，计算属性D依赖A和B，那么在D中可以直接修改C的值吗？  
> 答：可以。   
> 如果我又在D中修改A，会出现问题吗？ 
> 答：不会出现问题，会拿到新修改的值计算

> 计算属性A和B，如果A中用了B，B中用了A，会出现问题吗？如果出现问题，会造成什么影响？  
> 答：直接报错：超过最大调用堆栈大小

> 如果在data中定义了属性A，在计算属性也定义了A，会出现问题吗？   
> 答：会报警告，最后用的是data中的值，不用计算属性的值  

如果在data中这样定义，A的最终值是多少？  答：1

``` 
data() {
	this.A = 5
	return {
		A: 1,
		B: 2,
	}
},
```

# Hash和History区别(细说)？  
例如：Hash页面跳转的时候，会发起请求吗？History呢？

> hash模式  
我们先来认识下这位朋友 #，这个 # 就是hash符号，中文名哈希符或锚点，当然这在我们前端领域姑且这么称呼。
然后哈希符后面的值，我们称之为哈希值。OK，接下来我们继续分析他的原理。路由的哈希模式其实是利用了window可以监听`onhashchange`事件，也就是说你的url中的哈希值（#后面的值）如果有变化，前端是可以做到监听并做一些响应（搞点事情），这么一来，即使前端并没有发起http请求他也能够找到对应页面的代码块进行按需加载。

> history模式  
我们先介绍一下H5新推出的两个神器：pushState与replaceState
具体自行百度，简而言之，这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404。
那么如何去解决history模式下刷新报404的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效。
至此，我们的前端路由在实现与展示效果上又更进了一步！
总之，pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。


在history模式中，浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404了  
因此在线上部署基于 history API的单页面应用的时候，一定要后端配合支持才行，否则会出现大量的 404。
以最常用的 Nginx 为例，只需要在配置的 location / 中增加下面一行即可：  

``` 
try_files $uri /index.html
```


 # 如果页面中有输入框，刷新后不让输入框数据丢失，怎么做？   
 
 Vuex，Redux 不推荐，localStorage也不合适  
 
 sessionStorage挺合适的
 
 # React怎么保存当前组件的状态？      
**手动保存状态**  
手动保存状态即通过 React 提供的 componentWillUnmount 生命周期通过 redux 之类的状态管理库对数据进行保存，通过 componentDidMount 生命周期进行数据恢复，这也是目前最常见的解决方式，这里不展开讨论。

**通过路由实现状态保存**
由于状态丢失的主要原因是由于路由切换时导致组件被卸载，如果是这样，是否只需要保证组件不被卸载，或者在组件卸载之前将数据状态保存就可以解决我们的问题了，事实上目前社区的相关实现也正是这样。

核心思路：`路由匹配 -> 组件渲染 -> 切换路由 -> 组件卸载 => 路由匹配 -> 组件渲染 -> 切换路由 -> 组件隐藏`  
| 库/功能           | [react-keep-alive](https://github.com/StructureBuilder/react-keep-alive) | [react-keeper](https://github.com/vifird/react-keeper) | [react-router-cache-route](https://github.com/CJY0208/react-router-cache-route) | [react-activation](https://github.com/CJY0208/react-activation/) |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实现思路          | 将 KeepAlive 的组件藏于其 Provider 中，保证其不会被卸载 -    | 基于 react-router 完全实现一个自定义的路由库           | 改写 react-router 库的 Route 组件，控制渲染行为，使其不被卸载 | 同 react-keep-alive                                          |
| GitHub star       | 407                                                          | 708                                                    | 474                                                          | 217                                                          |
| NPM download      | < 300                                                        | < 200                                                  | ~ 3k                                                         | < 150                                                        |
| 使用方式          | KeepLive                                                     | CacheLink                                              | CacheRoute、CacheSwitch                                      | KeepAlive                                                    |
| Class 生命周期    | componentDidActivate componentWillUnactivate                 | -                                                      | componentDidCache componentDidRecover                        | componentDidActivate componentWillUnactivate                 |
| Function 生命周期 | useKeepAliveEffect                                           | -                                                      | -                                                            | useActivate useUnactivate                                    |
| 恢复滚动位置      | 支持                                                         | 支持                                                   | 支持                                                         | 支持                                                         |
| 缓存控制          | 支持                                                         | -                                                      | 支持（不友好）                                               | 支持                                                         |
| 总结              | ★★★★                                                         | ★★                                                     | ★★                                                           | ★★★★                                                         |
 
，

# OAuth授权认证流程(第三方登录)  

![fanjunyang_book](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/fanjunyang_book.jpg)  

# 什么是单点登录？单点登录怎么实现的？      
单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一
SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统
SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作
当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证  

举例：  
淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录  

![singledian](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/singledian.png)  

# 自己在封装组件时需要注意哪些点？怎么样才能让组件有更好的适用性？     

* 数据的传入  
  * 数据从父组件传入时应在props中加一些限制或验证   
  * props中的数据不能直接进行修改，如果要引用可进行深拷贝 直接复制不能接触双向绑定  

*  通用组件中的事件处理应尽量放到父组件中 通用组件本身只作为中转，避免数据污染，保证更换的通用性  
*  不要过分依赖Vuex  
*  合理运用scoped编写css，在编写组件的时候，可以在style标签中添加scoped,让标签中的样式只对当前组件生效，但是一味的使用scoped，肯定会产生大量的重复代码，所以在开发的时候，应避免在组件中写样式，当全局样式写好后，再针对每个组件，通过scoped属性添加组件样式  
*  最好留一个slot，为了让通用组件能适用更多场景，应尽量留一个slot以便进行个性化配置 






# 如何取消ajax请求？  
原生 Ajax 取消方式  
对于原生XHR对象来说，取消的ajax的关键是调用XHR对象的.abort()方法，请求被中断之后会触发 onabort 事件不会触发 error 事件  

``` 
let ajax = new XMLHttpRequest();
ajax.open("POST", "/api/sys/listTmallShop");
ajax.send(null);
ajax.onreadystatechange = function () {
    if (ajax.readyState === 4) {
        console.log(ajax.response);
    }
};
ajax.onabort = function () {
    console.log("请求被中断");
};
// 立即取消请求
ajax.abort();
```  
jquery 取消方式  
由于 jquery 的 ajax 函数会返回一个原生的 xhr 对象所以可以通过这个对象调用原生的 abort 方法取消请求，取消之后会触发 error 事件  

``` 
var jp = $.ajax({
    type: "post",
    url: "/api/sys/listTmallShop",
    data: {
        platform: "TMALL",
        page: 1
    },
    success: function (data) {
        console.log("成功了");
        console.log(data);
    },
    error: function (err) {
        console.log("取消了");
        console.log(err);
    }
});
jp.abort();
```  
axios 的取消方式  
axios的取消需要使用 CancelToken 获取取消令牌，并且用令牌标识单个请求，之后调用令牌的 cancel 即可取消  

``` 
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.post("/api/sys/listTmallShop", null, {
    cancelToken: source.token
}).catch(function (thrown) {
    if (axios.isCancel(thrown)) {
        console.log("取消了", thrown.message);
    } else {
        console.log("出错了");
    }
});

source.cancel("取消原因：老子愿意"); 
```  
如果多个请求可以多次执行 CancelToken.source() 拿到多个 token对象  
除了以上的方式还有一种方式可以取消请求  

``` 
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // An executor function receives a cancel function as a parameter
    cancel = c;
  })
});

// cancel the request
cancel();
```  


# React的hooks怎么模拟生命周期  

使用 hooks 模拟 componentDidMount  

``` 
function Example() {
  // 当我们指定第二个参数为空数组就可以代替我们类组件中的componentDidMount
  useEffect(() => {
  	console.log('Did mount!');
  }, []);  
  return <div></div>;
}
```    
使用 hooks 模拟 componentDidUpdate  

``` 
function Example() {
  // 当我们不指定第二个参数的时候就可以代替我们类组件中的componentDidUpdate
  useEffect(() => {
  	console.log('Did update!');
  });  
  return <div></div>;
}
```

使用 hooks 模拟 componentWillUnmount  

``` 
function Example() {
  // 当我们不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount
  useEffect(() => {
  	return () => {
	  console.log('will unmount');  
	}
  });  
  return <div></div>;
}
```  
想通过useEffect模拟componentDidUpdate生命周期，而去掉初次渲染时调用的 componentDidMount    
因为初次渲染只会发生一次，可以使用useRef立一个flag解决：

``` 
let mounting = useRef(true);
useEffect(() => {
	if (mounting.current) {
		console.log("初次")
		mounting.current = false;
		return 
	}
	console.log("DidUpdated")
});
```

useEffect 拥有两个参数，第一个参数作为回调函数会在浏览器布局和绘制完成后调用，因此它不会阻碍浏览器的渲染进程。第二个参数是一个数组
* 当数组存在并有值时，如果数组中的任何值发生更改，则每次渲染后都会触发回调。  
* 当它不存在时，每次渲染后都会触发回调。  
* 当它是一个空列表时，回调只会被触发一次，类似于 componentDidMount。  
* 当不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount  

# React函数组件和类组件区别以及使用场景  


# REM适配  

``` 
<script>
	;(function () {
		// 设计稿宽度 px
		var designWidth = 375
		// rem 基准字号 px
		var baseFontSize = 100
		// 最大适配宽度 px
		var maxAdaptWidth = 1024

		var adaptDevice = function () {
			var deviceWidth = document.documentElement.clientWidth
			deviceWidth = deviceWidth > maxAdaptWidth ? maxAdaptWidth : deviceWidth
			var scale = deviceWidth / designWidth
			var adaptRootFontSize = baseFontSize * scale
			document.querySelector('html').style.fontSize = adaptRootFontSize + 'px'
		}

		var timer = 0
		window.addEventListener('resize', function () {
			if (timer) {
				clearTimeout(timer)
				timer = 0
			}

			timer = setTimeout(function () {
				adaptDevice()
			}, 0)
		})

		setTimeout(adaptDevice, 0)
	}())
</script>
```  

 

# Webpack怎么提高打包速度？  
* 开启多线程打包（thread-loader）  
* 合理利用缓存（cache-loader、HardSourceWebpackPlugin、babel-loader）  
* 分包方式预编译资源模块（DLLPlugin）  
* 缩小构建目标，比如babel-loader不去解析node_modules    
* 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree-shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉  
* 对图片资源的压缩（image-webpack-loader）  


# 怎么用JS实现一个链表？  

# JS怎么遍历一个链表？  

# 谈谈你对前端工程化的理解？  

# 如果给你个项目，你会选择什么框架(Vue或React)?  


# Vuex实现原理(和Redux对比)    

# JS隐式类型转换了解过吗？    
输出打印内容  

``` 
if([] == false) {
  console.log(1)
}

if({} == false) {
  console.log(2)
}

if([]) {
  console.log(3)
}

if([1] == [1]) {
  console.log(4)
}
```

# uniApp中的setData了解过吗？  
  

# 说说对React事件机制的理解    
React基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等
在React中这套事件机制被称之为合成事件  

自行[百度](https://www.baidu.com/)
 
 
  

# 什么是死锁？  

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程    

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

* 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。  


* 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

# 堆和栈的区别  

# 给个1000条数据的列表，用JS动态渲染节点  
一次渲染20条  

# 自定义一个table组件  
动态添加表头等    

# 怎样理解大前端的概念  

