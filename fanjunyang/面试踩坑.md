[toc]  


# Node如何创建一个子进程？  

![Node1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Node1.png)  


# 简单介绍下Koa  
NodeJS本质上就是使用JS语言写的解析器，NodeJS给了JS在服务器端的运行环境  

Koa 是一个使用 Node.js 的 web 开发框架，其核心是反复使用的洋葱模型中间件，通过中间件解决 web 开发中的 http 处理、业务逻辑实现  

**介绍下洋葱模型**     

[Express和Koa分析](https://juejin.cn/post/6844903922428035085)  

# Node是如何处理高并发的？  
* eventproxy  
* async.queue  
* async.mapLimit  



# 不用all方法实现一个Promise.all功能    

``` 
function promiseAll(iterable) {
    const array = [...iterable]
    const result = []
    return new Promise((reslove, reject) => {
        for(let i = 0; i < array.length; i++) {
            Promise.resolve(array[i]).then(res => {
                result.push(res)
                result.length === array.length && reslove(result)
            }).catch(reason => {
                reject(reason)
            })
        }
    })
}
```


# 如果后端返回数据量比较大怎么办？  
从后端的角度：
* 尽量预处理并规整返回的数据：给到合理的数据格式以及需要用作展示的数据，尽量减轻前端的数据处理逻辑。 

从前端的角度：
* 数据传输大，意味着会有较长的网络传输时间，那么最好的方式就是要进行数据缓存。
* 从另外一个角度，可以使用 NodeJS 中间层的方式，不经过浏览器先行请求接口数据并将数据预处理，前端通过调用中间层暴露的接口来调用，浏览器获得的即为中间层处理后的数据，前端可以减轻大量的逻辑处理，拿到的数据可以直接使用，也可以提高页面渲染效率。  
* 当然，渲染是浏览器的事，但是最好也做到按需加载提高性能。      
* 用虚拟列表


# Node端如何做实时监控、如何保存日志？      

目前采用PM2做Node进程监控和管理，使用PM2的配置来保存日志输出  

可以使用[log.io](https://github.com/NarrativeScience/log.io)来做服务的实时监控  

# Redux中都有什么方法？有什么中间件来处理Redux?    

[一篇足矣](https://juejin.cn/post/6844903983299952648)  



# 自己在封装组件时需要注意哪些点？怎么样才能让组件有更好的适用性？     

* 数据的传入  
  * 数据从父组件传入时应在props中加一些限制或验证   
  * props中的数据不能直接进行修改，如果要引用可进行深拷贝 直接复制不能接触双向绑定  

*  通用组件中的事件处理应尽量放到父组件中 通用组件本身只作为中转，避免数据污染，保证更换的通用性  
*  不要过分依赖Vuex  
*  合理运用scoped编写css，在编写组件的时候，可以在style标签中添加scoped,让标签中的样式只对当前组件生效，但是一味的使用scoped，肯定会产生大量的重复代码，所以在开发的时候，应避免在组件中写样式，当全局样式写好后，再针对每个组件，通过scoped属性添加组件样式  
*  最好留一个slot，为了让通用组件能适用更多场景，应尽量留一个slot以便进行个性化配置 


# Webpack怎么提高打包速度？  
* 开启多线程打包（thread-loader）  
* 合理利用缓存（cache-loader、HardSourceWebpackPlugin、babel-loader）  
* 分包方式预编译资源模块（DLLPlugin）  
* 缩小构建目标，比如babel-loader不去解析node_modules    
* 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree-shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉  
* 对图片资源的压缩（image-webpack-loader）  

  


# 谈谈你对前端工程化的理解？  

# 如果给你个项目，你会选择什么框架(Vue或React)?  



# uniApp中的setData了解过吗？  

# 什么是死锁？  

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程    

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

* 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。  


* 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。


# 给个1000条数据的列表，用JS动态渲染节点  
一次渲染20条  

# 自定义一个table组件  
动态添加表头等    

# 怎样理解大前端的概念  

