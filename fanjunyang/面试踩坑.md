[toc]  

# this在jquery中的使用，this关键字  
this表示JS的DOM对象
$(this)表示把DOM对象转换为Jquery对象  

# jquery的优点  
1.轻量  
2.丰富的DOM选择器  
3.链式表达式  
4.事件、样式、动画支持  
5.跨浏览器兼容  
6.可扩展性  

# delete 和 Vue.delete区别？  
delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。  
Vue.delete 直接删除了数组 改变了数组的键值。  

# axios优点  
1.简单易用  
2.兼容性好  
3.通用性好  
4.稳定  
5.提供了一些并发请求  
6.支持拦截请求和响应  
7.安全，支持防御  
8.支持Promise  

# MVC、MVP、MVVM区别？  
## MVC  
实线表示调用，虚线表示通知   

![MVC1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/xx.png)    

Controller 是 MVC 中的 C，指控制层，在 Controller 层会接收用户所有的操作，并根据写好的代码进行相应的操作——触发 Model 层，或者触发 View 层，抑或是两者都触发。  
需要注意：Controller 层触发 View 层时，并不会更新 View 层中的数据，View 层中的数据是通过监听 Model 层数据变化而自动更新的，与 Controller 层无关。  

![MVC2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVC2.png)

## MVP  

![MVP1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP1.png)

在 MVC 框架中，View 层可以通过访问 Model 层来更新，但在 MVP 框架中，View 层不能再直接访问 Model 层，必须通过 Presenter 层提供的接口，然后 Presenter 层再去访问 Model 层。

这看起来有点多此一举，但用处着实不小，主要有两点：  
* 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。  
* 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。  

![MVP2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP2.png)  

View 层与 Model 层确实互不干涉，View 层也自由了很多。但还是有问题，因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。  
而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。  

## MVVM   

![MVVM1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM1.png)  

可能感觉 MVVM 的框架图与 MVP 的框架图相似，确实如此，两者都是从 View 层开始触发用户的操作，之后经过第三层，最后到达 Model 层。但是关键问题是这第三层的内容， ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，两者孰优孰劣不言而喻。   

![MVVM2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM2.png)  


# created和mounted的区别?  
created中data已经挂载,DOM还没挂载  

mounted中调用方法改变data数据可能引起二次渲染  
mounted中data和DOM都挂载了   

# 性能优化  
* data优化（对象层级不要过深，不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据））  
* 巧妙利用指令v-if(show)，使用v-for要绑定key   
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 缓存和压缩  
* HTTP优化  
* computed 和 watch 区分使用场景
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染   
* 文件压缩，减小资源大小  
* 小图片转base64，减少请求  
* 雪碧图，减少请求  
* 渲染优化（重绘、回流）  
* 减少cookie的使用，减少请求携带大小  

# `==`与`===`的区别，是否`===`就完全靠谱？  
不一定靠谱，例如 `0 === -0`就为true，`NaN === NaN`为false，判断两个变量是否完全相等可以使用ES6新增的API，`Object.is(0, -0)`，就可以准确区分  


# Node如何创建一个子进程？  

![Node1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Node1.png)  

# React的hooks执行原理？  


# 简单介绍下Koa  
NodeJS本质上就是使用JS语言写的解析器，NodeJS给了JS在服务器端的运行环境  

Koa 是一个使用 Node.js 的 web 开发框架，其核心是反复使用的洋葱模型中间件，通过中间件解决 web 开发中的 http 处理、业务逻辑实现  

**介绍下洋葱模型**     

[Express和Koa分析](https://juejin.cn/post/6844903922428035085)  

# Node是如何处理高并发的？  
* eventproxy  
* async.queue  
* async.mapLimit  


# 介绍下Vue插件的使用,怎么自定义插件/指令,Vue.use()怎么使用？  
Vue.use方法主要做了如下的事：  
* 检查插件是否安装，如果安装了就不再安装  
* 如果没有安装，那么调用插件的install方法，并传入Vue实例    

Vue 自定义指令有全局注册和局部注册两种方式。  
注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。   

指令定义函数提供了几个钩子函数（可选）：
* bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。
* inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。
* update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。
* componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。
* unbind: 只调用一次， 指令与元素解绑时调用。  

![Vue.use](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Vue.use.png)   

# 观察者模式与发布订阅模式  
观察者模式中： 
* 状态发布者维护了一个观察者的列表，明确的知道有哪些观察者存在，将状态变化直接通知给观察者
* 状态的观察者也明确的知道自己观察的状态是描述的哪一个对象
* 甚至需要这种相互知道的关系来处理逻辑（比如需要明确知道哪一个按钮被点击，处理对应的逻辑）

发布订阅模式：  
* 事件的发布者只发布事件，不关心这个事件被谁获取了，通常将事件发给一个中间件，由中间件再去分发事件
* 事件的订阅者只关心事件本身，不关心这个事件是谁发布的，通常在中间件中去注册观察某个事件
* 中间件中去维护事件类别对应的订阅者列表，当收到事件后，去对应列表中通知订阅者们  

[两种模式讲解](https://juejin.cn/post/6844903921211670536)  

## 观察者模式简单实现  

``` 
//被观察者
class Subject{
    constructor(){
        this.arr = []   //存储观察者
        this.state = "开心..."  //存储被观察者状态
    }
    attach(unit){
        this.arr.push(unit)
    }
    //改变状态
    setState(newState){
        this.state = newState
        this.arr.forEach(unit=>unit.update(newState))
    }
}
//观察者
class Observer{
    constructor(name){
        this.name = name
    }
    update(newState){
        console.log(this.name,"状态：",newState);
    }
}
let s = new Subject("宝宝")
let o1 = new Observer("我")
let o2 = new Observer("你")

s.attach(o1)
s.attach(o2)
console.log(s.state);   //开心...
s.setState("不开心...");    //我 状态： 不开心...   你 状态： 不开心...
console.log(s.state);   //不开心...
```  
## 发布订阅简单实现  

``` 
let e = {
    arr:[],
    on(fn){
        this.arr.push(fn)
    },
    emit(){
        this.arr.forEach(fn=>fn())
    }
}
e.on(()=>{
    console.log("哈哈 1");
})
e.on(()=>{
    console.log("哈哈 2");
})

//调一次打印一次
e.emit()    //哈哈 1  哈哈 2  
e.emit()    //哈哈 1  哈哈 2 
```

# 不用all方法实现一个Promise.all功能    

``` 
function promiseAll(iterable) {
    const array = [...iterable]
    const result = []
    return new Promise((reslove, reject) => {
        for(let i = 0; i < array.length; i++) {
            Promise.resolve(array[i]).then(res => {
                result.push(res)
                result.length === array.length && reslove(result)
            }).catch(reason => {
                reject(reason)
            })
        }
    })
}
```

# NaN是什么类型的，在什么情况下会出现？
NaN是属于JavaScript的数值类型Number类型。  
NaN意思是指数据not a number不是一个数字，但是NaN却属于数值类型。  

那么NaN在什么情况下会出现呢？ 

``` 
let a = 'abc'
let b = 5
let c = a * b
console.log(c)

console.log(NaN === NaN) // false
```

# 如果后端返回数据量比较大怎么办？  
从后端的角度：
* 尽量预处理并规整返回的数据：给到合理的数据格式以及需要用作展示的数据，尽量减轻前端的数据处理逻辑。 

从前端的角度：
* 数据传输大，意味着会有较长的网络传输时间，那么最好的方式就是要进行数据缓存。
* 从另外一个角度，可以使用 NodeJS 中间层的方式，不经过浏览器先行请求接口数据并将数据预处理，前端通过调用中间层暴露的接口来调用，浏览器获得的即为中间层处理后的数据，前端可以减轻大量的逻辑处理，拿到的数据可以直接使用，也可以提高页面渲染效率。  
* 当然，渲染是浏览器的事，但是最好也做到按需加载提高性能。      
* 用虚拟列表


# Node端如何做实时监控、如何保存日志？      

目前采用PM2做Node进程监控和管理，使用PM2的配置来保存日志输出  

可以使用[log.io](https://github.com/NarrativeScience/log.io)来做服务的实时监控  

# Redux中都有什么方法？有什么中间件来处理Redux?    

[一篇足矣](https://juejin.cn/post/6844903983299952648)  

# Vue中data/computed相关问题  
> data中有属性A、B、C，计算属性D依赖A和B，那么在D中可以直接修改C的值吗？  
> 答：可以。   
> 如果我又在D中修改A，会出现问题吗？ 
> 答：不会出现问题，会拿到新修改的值计算

> 计算属性A和B，如果A中用了B，B中用了A，会出现问题吗？如果出现问题，会造成什么影响？  
> 答：直接报错：超过最大调用堆栈大小

> 如果在data中定义了属性A，在计算属性也定义了A，会出现问题吗？   
> 答：会报警告，最后用的是data中的值，不用计算属性的值  

如果在data中这样定义，A的最终值是多少？  答：1

``` 
data() {
	this.A = 5
	return {
		A: 1,
		B: 2,
	}
},
```

# Hash和History区别(细说)？  
例如：Hash页面跳转的时候，会发起请求吗？History呢？

> hash模式  
我们先来认识下这位朋友 #，这个 # 就是hash符号，中文名哈希符或锚点，当然这在我们前端领域姑且这么称呼。
然后哈希符后面的值，我们称之为哈希值。OK，接下来我们继续分析他的原理。路由的哈希模式其实是利用了window可以监听`onhashchange`事件，也就是说你的url中的哈希值（#后面的值）如果有变化，前端是可以做到监听并做一些响应（搞点事情），这么一来，即使前端并没有发起http请求他也能够找到对应页面的代码块进行按需加载。

> history模式  
我们先介绍一下H5新推出的两个神器：pushState与replaceState
具体自行百度，简而言之，这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404。
那么如何去解决history模式下刷新报404的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效。
至此，我们的前端路由在实现与展示效果上又更进了一步！
总之，pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。


在history模式中，浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404了  
因此在线上部署基于 history API的单页面应用的时候，一定要后端配合支持才行，否则会出现大量的 404。
以最常用的 Nginx 为例，只需要在配置的 location / 中增加下面一行即可：  

``` 
try_files $uri /index.html
```


 # 如果页面中有输入框，刷新后不让输入框数据丢失，怎么做？   
 
 Vuex，Redux 不推荐，localStorage也不合适  
 
 sessionStorage挺合适的
 
 # React怎么保存当前组件的状态？      
**手动保存状态**  
手动保存状态即通过 React 提供的 componentWillUnmount 生命周期通过 redux 之类的状态管理库对数据进行保存，通过 componentDidMount 生命周期进行数据恢复，这也是目前最常见的解决方式，这里不展开讨论。

**通过路由实现状态保存**
由于状态丢失的主要原因是由于路由切换时导致组件被卸载，如果是这样，是否只需要保证组件不被卸载，或者在组件卸载之前将数据状态保存就可以解决我们的问题了，事实上目前社区的相关实现也正是这样。

核心思路：`路由匹配 -> 组件渲染 -> 切换路由 -> 组件卸载 => 路由匹配 -> 组件渲染 -> 切换路由 -> 组件隐藏`  
| 库/功能           | [react-keep-alive](https://github.com/StructureBuilder/react-keep-alive) | [react-keeper](https://github.com/vifird/react-keeper) | [react-router-cache-route](https://github.com/CJY0208/react-router-cache-route) | [react-activation](https://github.com/CJY0208/react-activation/) |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实现思路          | 将 KeepAlive 的组件藏于其 Provider 中，保证其不会被卸载 -    | 基于 react-router 完全实现一个自定义的路由库           | 改写 react-router 库的 Route 组件，控制渲染行为，使其不被卸载 | 同 react-keep-alive                                          |
| GitHub star       | 407                                                          | 708                                                    | 474                                                          | 217                                                          |
| NPM download      | < 300                                                        | < 200                                                  | ~ 3k                                                         | < 150                                                        |
| 使用方式          | KeepLive                                                     | CacheLink                                              | CacheRoute、CacheSwitch                                      | KeepAlive                                                    |
| Class 生命周期    | componentDidActivate componentWillUnactivate                 | -                                                      | componentDidCache componentDidRecover                        | componentDidActivate componentWillUnactivate                 |
| Function 生命周期 | useKeepAliveEffect                                           | -                                                      | -                                                            | useActivate useUnactivate                                    |
| 恢复滚动位置      | 支持                                                         | 支持                                                   | 支持                                                         | 支持                                                         |
| 缓存控制          | 支持                                                         | -                                                      | 支持（不友好）                                               | 支持                                                         |
| 总结              | ★★★★                                                         | ★★                                                     | ★★                                                           | ★★★★                                                         |
 

# 怎么结束for、forEach、Map循环？怎么跳出本轮循环、整个循环和嵌套循环？    


## return语句的作用
(1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行
(2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致，可以使用强制类型转换来是数据类型一致
(3) return 当方法说明中用void声明返回类型为空时，应使用这种格式，不返回任何值。

## break语句的作用
(1) 只能在循环体内和switch语句体内使用break语句。
(2) 当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。
(3) 当break出现在循环体中，但并不在switch语句体内时，则在执行break后，跳出本层循环体。
(4) 在循环结构中，应用break语句使流程跳出本层循环体，从而提前结束本层循环

## continue语句作用
(1) continue语句的一般形式为：continue;
(2) 其作用是结束本次循环，即跳过本次循环体中余下尚未执行的语句，接着再一次进行循环的条件判定。
(3) 注意：执行continue语句并没有使整个循环终止。在while和do-while循环中，continue语句使得流程直接跳到循环控制条件的测试部分 ，然后决定循环是否继续进行。
(4) 在for 循环中，遇到continue后，跳过循环体中余下的语句，而去对for语句中的“表达式3”求值，然后进行“表达式2”的条件测试，

# OAuth授权认证流程(第三方登录)  

![fanjunyang_book](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/fanjunyang_book.jpg)  

# 什么是单点登录？单点登录怎么实现的？      
单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一
SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统
SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作
当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证  

举例：  
淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录  

![singledian](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/singledian.png)  

# 自己在封装组件时需要注意哪些点？怎么样才能让组件有更好的适用性？     

* 数据的传入  
  * 数据从父组件传入时应在props中加一些限制或验证   
  * props中的数据不能直接进行修改，如果要引用可进行深拷贝 直接复制不能接触双向绑定  

*  通用组件中的事件处理应尽量放到父组件中 通用组件本身只作为中转，避免数据污染，保证更换的通用性  
*  不要过分依赖Vuex  
*  合理运用scoped编写css，在编写组件的时候，可以在style标签中添加scoped,让标签中的样式只对当前组件生效，但是一味的使用scoped，肯定会产生大量的重复代码，所以在开发的时候，应避免在组件中写样式，当全局样式写好后，再针对每个组件，通过scoped属性添加组件样式  
*  最好留一个slot，为了让通用组件能适用更多场景，应尽量留一个slot以便进行个性化配置 



# BOM与DOM的区别？  
`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 `JavaScript` 有能力与浏览器"对话"。   
`DOM （Document Object Model）`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。 `DOM `是 `W3C`（万维网联盟）的标准。`DOM` 定义了访问 `HTML` 和` XML` 文档的标准： "W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。" `W3C DOM` 标准被分为 3 个不同的部分：

- 核心 `DOM` - 针对任何结构化文档的标准模型
- `XML DOM` - 针对 XML 文档的标准模型
- `HTML DOM` - 针对 HTML 文档的标准模型

什么是` XML DOM`？ `XML DOM` 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？ HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法

# for...in...与for...of...区别？  
for...in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。像 Array和Object使用内置构造函数所创建的对象都会继承自Object.prototype和String.prototype的不可枚举属性，例如 String 的 indexOf()  方法或 Object的toString()方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。  

for...of语句在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句  

无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
* for...in语句以任意顺序迭代对象的可枚举属性。  
* for...of 语句遍历可迭代对象定义要迭代的数据。    

总结：  
for in 一般用来遍历对象的key、for of 一般用来遍历数组的value  
for … in

* for … in 获取的是对象的键名;
* for … in会遍历对象的整个原型链,性能非常差不推荐使用;
* 对于数组的遍历,for … in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性);  


for … of
* for … of遍历获取的是对象的键值;
* for … of只遍历当前对象不会遍历原型链;
* 对于数组的遍历,for … of只返回数组的下标对应的属性值;

# 如何让一个对象变成可迭代对象？    
1. 使用Array.from  
2. 使用ES6中的展开运算符[...arr]  
3. 自定义一个genertor迭代器  

# 如何取消ajax请求？  
原生 Ajax 取消方式  
对于原生XHR对象来说，取消的ajax的关键是调用XHR对象的.abort()方法，请求被中断之后会触发 onabort 事件不会触发 error 事件  

``` 
let ajax = new XMLHttpRequest();
ajax.open("POST", "/api/sys/listTmallShop");
ajax.send(null);
ajax.onreadystatechange = function () {
    if (ajax.readyState === 4) {
        console.log(ajax.response);
    }
};
ajax.onabort = function () {
    console.log("请求被中断");
};
// 立即取消请求
ajax.abort();
```  
jquery 取消方式  
由于 jquery 的 ajax 函数会返回一个原生的 xhr 对象所以可以通过这个对象调用原生的 abort 方法取消请求，取消之后会触发 error 事件  

``` 
var jp = $.ajax({
    type: "post",
    url: "/api/sys/listTmallShop",
    data: {
        platform: "TMALL",
        page: 1
    },
    success: function (data) {
        console.log("成功了");
        console.log(data);
    },
    error: function (err) {
        console.log("取消了");
        console.log(err);
    }
});
jp.abort();
```  
axios 的取消方式  
axios的取消需要使用 CancelToken 获取取消令牌，并且用令牌标识单个请求，之后调用令牌的 cancel 即可取消  

``` 
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.post("/api/sys/listTmallShop", null, {
    cancelToken: source.token
}).catch(function (thrown) {
    if (axios.isCancel(thrown)) {
        console.log("取消了", thrown.message);
    } else {
        console.log("出错了");
    }
});

source.cancel("取消原因：老子愿意"); 
```  
如果多个请求可以多次执行 CancelToken.source() 拿到多个 token对象  
除了以上的方式还有一种方式可以取消请求  

``` 
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // An executor function receives a cancel function as a parameter
    cancel = c;
  })
});

// cancel the request
cancel();
```  

# href与src有什么区别？  

href是Hypertext Reference的简写，表示超文本**引用**，指向网络资源所在位置。  
常见场景:  

``` 
<a href="http://www.baidu.com"></a> 
<link type="text/css" rel="stylesheet" href="common.css">
```  
src是source的简写，目的是要把文件**下载**到html页面中去。  

``` 
<img src="img/girl.jpg"> 
<iframe src="top.html"> 
<script src="show.js">
```  
作用结果：  
* href 用于在当前文档和引用资源之间确立联系  
* src 用于替换当前内容  


# React的hooks怎么模拟生命周期  

使用 hooks 模拟 componentDidMount  

``` 
function Example() {
  // 当我们指定第二个参数为空数组就可以代替我们类组件中的componentDidMount
  useEffect(() => {
  	console.log('Did mount!');
  }, []);  
  return <div></div>;
}
```    
使用 hooks 模拟 componentDidUpdate  

``` 
function Example() {
  // 当我们不指定第二个参数的时候就可以代替我们类组件中的componentDidUpdate
  useEffect(() => {
  	console.log('Did update!');
  });  
  return <div></div>;
}
```

使用 hooks 模拟 componentWillUnmount  

``` 
function Example() {
  // 当我们不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount
  useEffect(() => {
  	return () => {
	  console.log('will unmount');  
	}
  });  
  return <div></div>;
}
```  
想通过useEffect模拟componentDidUpdate生命周期，而去掉初次渲染时调用的 componentDidMount    
因为初次渲染只会发生一次，可以使用useRef立一个flag解决：

``` 
let mounting = useRef(true);
useEffect(() => {
	if (mounting.current) {
		console.log("初次")
		mounting.current = false;
		return 
	}
	console.log("DidUpdated")
});
```

useEffect 拥有两个参数，第一个参数作为回调函数会在浏览器布局和绘制完成后调用，因此它不会阻碍浏览器的渲染进程。第二个参数是一个数组
* 当数组存在并有值时，如果数组中的任何值发生更改，则每次渲染后都会触发回调。  
* 当它不存在时，每次渲染后都会触发回调。  
* 当它是一个空列表时，回调只会被触发一次，类似于 componentDidMount。  
* 当不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount  

# React函数组件和类组件区别以及使用场景  


# REM适配  

``` 
<script>
	;(function () {
		// 设计稿宽度 px
		var designWidth = 375
		// rem 基准字号 px
		var baseFontSize = 100
		// 最大适配宽度 px
		var maxAdaptWidth = 1024

		var adaptDevice = function () {
			var deviceWidth = document.documentElement.clientWidth
			deviceWidth = deviceWidth > maxAdaptWidth ? maxAdaptWidth : deviceWidth
			var scale = deviceWidth / designWidth
			var adaptRootFontSize = baseFontSize * scale
			document.querySelector('html').style.fontSize = adaptRootFontSize + 'px'
		}

		var timer = 0
		window.addEventListener('resize', function () {
			if (timer) {
				clearTimeout(timer)
				timer = 0
			}

			timer = setTimeout(function () {
				adaptDevice()
			}, 0)
		})

		setTimeout(adaptDevice, 0)
	}())
</script>
```  
# 怎么判断DOM加载完成  
判断所有DOM加载完成使用onload  

``` 
window.onload = function(){
    
}
```
判断某个DOM节点是否加载完毕  

**readyState**  

document.readyState 返回当前文档的状态，属性如下： 
* uninitialized 还未开始加载
* loading 加载中
* interactive 已加载，文档与用户可以开始交互
* complete 加载完成

**DOMContentLoaded**  
当 DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash  


# Jquery(callback)  
当传进去的参数是函数的时候，则在document对象上绑定一个ready事件监听函数，当DOM结构加载完成的时候执行  

``` 
$(function(){

})
//以上代码和下面的效果是一样的
$(document).ready(function(){
    ...//代码
})
```  

# Webpack怎么提高打包速度？  
* 开启多线程打包（thread-loader）  
* 合理利用缓存（cache-loader、HardSourceWebpackPlugin、babel-loader）  
* 分包方式预编译资源模块（DLLPlugin）  
* 缩小构建目标，比如babel-loader不去解析node_modules    
* 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree-shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉  
* 对图片资源的压缩（image-webpack-loader）  

# Jquery与Zepto有什么区别？  
 Zepto专用于手机端  
jQuery专用于pc端 （但jq又开发出了jquery-mobile,专门用于手机）    

* Zepto特点：Zepto是为现代智能手机浏览器推出的Javascript 框架, 有着和jQuery相似的语法, 但是和jQuery相比下来, 他有很多的优点, 在大小方面 , 压缩后的 zepto.min.js 大小只有21K, 使用服务器端 gzip 压缩后大小只有5~10K, 可以说非常的小, 功能很齐全, 并且多出来了一些触摸屏的事件,它对PC的浏览器就不是那么理想,尤其是在IE上直接过滤不兼容, 所以这个轻量级的js用它来开发手机端和iOS，Android网页都是是不错的选择，极大的减轻了整个app的负载量。  

* jquery特点：jquery主要是用于PC端的页面开发中，jquery是目前最流行的javascript框架，以其兼容全部主流浏览器，插件丰富，代码简洁，最关键的是更新快，其中最好的dom选择器被广泛的使用。而手机wap方面的话，jquery也推出jquery-mobile，也很好用。  

* 相同点：Zepto最初是为移动端开发的库，是jQuery的轻量级替代品，因为它的API和jQuery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，Zepto所提供的工具足以满足开发程序的需要。大多数在jQuery中·常用的API和方法Zepto都有，Zepto中还有一些jQuery中没有的。另外，因为Zepto的API大部分都能和jQuery兼容，所以用起来极其容易，如果熟悉jQuery，就能很容易掌握Zepto。你可用同样的方式重用jQuery中的很多方法，也可以方面地把方法串在一起得到更简洁的代码，甚至不用看它的文档。  

* 不同点：  
  * 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。  
  * Dom操作的区别  
  * 事件触发的区别  
  * 事件委托的区别  
  * width()和height()的区别：Zepto由盒模型(box-sizing)决定，jQuery会忽略盒模型  
  * 等等。。。  

# 怎么用JS实现一个链表？  

# JS怎么遍历一个链表？  

# 谈谈你对前端工程化的理解？  

# 如果给你个项目，你会选择什么框架(Vue或React)?  

# 实现0.5px的线    

# Vuex实现原理(和Redux对比)    

# JS隐式类型转换了解过吗？    
输出打印内容  

``` 
if([] == false) {
  console.log(1)
}

if({} == false) {
  console.log(2)
}

if([]) {
  console.log(3)
}

if([1] == [1]) {
  console.log(4)
}
```

# uniApp中的setData了解过吗？  

# 使用REM时给body加可以吗？  

# 说说对React事件机制的理解    
React基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等
在React中这套事件机制被称之为合成事件  

自行[百度](https://www.baidu.com/)
 
 
  

# 进程、线程区别？   

https://juejin.cn/post/6844903848780234759  

# 进程间通信方式  

[进程间通信(IPC)](https://link.zhihu.com/?target=https%3A//blog.csdn.net/LEON1741/article/details/77934508)大概有这几种：

- 匿名管道
- 命名管道
- 信号量
- 消息队列
- 信号
- 共享内存
- 套接字

从技术上划分又可以划分成以下四种：

1. 消息传递(管道，FIFO，消息队列)
2. 同步(互斥量，条件变量，读写锁等)
3. 共享内存(匿名的，命名的)
4. 远程过程调用

# 什么是死锁？  

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程    

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

* 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。  


* 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。

# 堆和栈的区别  

# 给个1000条数据的列表，用JS动态渲染节点  
一次渲染20条  

# 自定义一个table组件  
动态添加表头等    

# 怎样理解大前端的概念  

