[toc]  


# 不用all方法实现一个Promise.all功能    

``` 
function promiseAll(iterable) {
    const array = [...iterable]
    const result = []
    return new Promise((reslove, reject) => {
        for(let i = 0; i < array.length; i++) {
            Promise.resolve(array[i]).then(res => {
                result.push(res)
                result.length === array.length && reslove(result)
            }).catch(reason => {
                reject(reason)
            })
        }
    })
}
```


# 如果后端返回数据量比较大怎么办？  
从后端的角度：
* 尽量预处理并规整返回的数据：给到合理的数据格式以及需要用作展示的数据，尽量减轻前端的数据处理逻辑。 

从前端的角度：
* 数据传输大，意味着会有较长的网络传输时间，那么最好的方式就是要进行数据缓存。
* 从另外一个角度，可以使用 NodeJS 中间层的方式，不经过浏览器先行请求接口数据并将数据预处理，前端通过调用中间层暴露的接口来调用，浏览器获得的即为中间层处理后的数据，前端可以减轻大量的逻辑处理，拿到的数据可以直接使用，也可以提高页面渲染效率。  
* 当然，渲染是浏览器的事，但是最好也做到按需加载提高性能。      
* 用虚拟列表

# Webpack怎么提高打包速度？  
* 开启多线程打包（thread-loader）  
* 合理利用缓存（cache-loader、HardSourceWebpackPlugin、babel-loader）  
* 分包方式预编译资源模块（DLLPlugin）  
* 缩小构建目标，比如babel-loader不去解析node_modules    
* 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree-shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉  
* 对图片资源的压缩（image-webpack-loader）  

  

# 如果给你个项目，你会选择什么框架(Vue或React)?  


# uniApp中的setData了解过吗？  


# 给个1000条数据的列表，用JS动态渲染节点  
一次渲染20条  

# 自定义一个table组件  
动态添加表头等    
  

