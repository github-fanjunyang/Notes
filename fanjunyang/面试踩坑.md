[toc]  

# this在jquery中的使用，this关键字  
this表示JS的DOM对象
$(this)表示把DOM对象转换为Jquery对象  

# jquery的优点  
1.轻量  
2.丰富的DOM选择器  
3.链式表达式  
4.事件、样式、动画支持  
5.跨浏览器兼容  
6.可扩展性  

# delete 和 Vue.delete区别？  
delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。  
Vue.delete 直接删除了数组 改变了数组的键值。  

# axios优点  
1.简单易用  
2.兼容性好  
3.通用性好  
4.稳定  
5.提供了一些并发请求  
6.支持拦截请求和响应  
7.安全，支持防御  
8.支持Promise  

# MVC、MVP、MVVM区别？  
## MVC  
实线表示调用，虚线表示通知   

![MVC1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/xx.png)    

Controller 是 MVC 中的 C，指控制层，在 Controller 层会接收用户所有的操作，并根据写好的代码进行相应的操作——触发 Model 层，或者触发 View 层，抑或是两者都触发。  
需要注意：Controller 层触发 View 层时，并不会更新 View 层中的数据，View 层中的数据是通过监听 Model 层数据变化而自动更新的，与 Controller 层无关。  

![MVC2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVC2.png)

## MVP  

![MVP1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP1.png)

在 MVC 框架中，View 层可以通过访问 Model 层来更新，但在 MVP 框架中，View 层不能再直接访问 Model 层，必须通过 Presenter 层提供的接口，然后 Presenter 层再去访问 Model 层。

这看起来有点多此一举，但用处着实不小，主要有两点：  
* 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。  
* 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。  

![MVP2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVP2.png)  

View 层与 Model 层确实互不干涉，View 层也自由了很多。但还是有问题，因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。  
而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。  

## MVVM   

![MVVM1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM1.png)  

可能感觉 MVVM 的框架图与 MVP 的框架图相似，确实如此，两者都是从 View 层开始触发用户的操作，之后经过第三层，最后到达 Model 层。但是关键问题是这第三层的内容， ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，两者孰优孰劣不言而喻。   

![MVVM2](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MVVM2.png)  


# created和mounted的区别?  
created中data已经挂载,DOM还没挂载  

mounted中调用方法改变data数据可能引起二次渲染  
mounted中data和DOM都挂载了   

# 性能优化  
* data优化（对象层级不要过深，不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据））  
* 巧妙利用指令v-if(show)，使用v-for要绑定key   
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 缓存和压缩  
* HTTP优化  
* computed 和 watch 区分使用场景
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染   
* 文件压缩，减小资源大小  
* 小图片转base64，减少请求  
* 雪碧图，减少请求  
* 渲染优化（重绘、回流）  
* 减少cookie的使用，减少请求携带大小  

# `==`与`===`的区别，是否`===`就完全靠谱？  
不一定靠谱，例如 `0 === -0`就为true，`NaN === NaN`为false，判断两个变量是否完全相等可以使用ES6新增的API，`Object.is(0, -0)`，就可以准确区分  

# HTTP如何实现长连接?  
* HTTP分为长连接和短连接,其实本质上说的是TCP的长短连接。TCP连接是一个双向的通道,它是可以保持一段时间不关闭的,因此TCP连接才有真正的长连接和短连接这一个说法。
* 长连接是指的是TCP连接,而不是HTTP连接。
* TCP长连接可以复用一个TCP连接来发起多次HTTP请求,这样可以减少资源消耗,比如一次请求HTML,短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接,在响应头设置Connection为keep-alive, HTTP1.1默认是长连接,而HTTP 1.0协议也支持长连接，但是默认是关闭的。    

# POST和GET有哪些区别?
* 请求参数: GET把参数包含在URL中,用&连接起来; POST通过request body传递参数。
* 请求缓存: GET请求会被主动Cache,而POST请求不会，除非手动设置。
* 收藏为书签: GET请求支持收藏为书签, POST请求不支持。
* 安全性: POST比GET安全, GET请求在浏览器回退时是无害的,而POST会再次请求。
* 历史记录: GET请求参数会被完整保留在浏览历史记录里,而POST中的参数不会被保留。
* 编码方式: GET请求只能进行ur编码,而POST支持多种编码方式。
* 参数数据类型: GET只接受ASCIl字符,而POST没有限制数据类型。
* 数据包: GET产生一个TCP数据包; POST可能产生两个TCP数据包。

# Node如何创建一个子进程？  

![Node1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Node1.png)  

# React的hooks执行原理？  

# Http2.X与Http1.X有什么区别？  
1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别

2.HTTP2支持多路复用
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求

3.HTTP2头部压缩
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了

4.HTTP2支持服务器推送
HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容  

# 简单介绍下Koa  
NodeJS本质上就是使用JS语言写的解析器，NodeJS给了JS在服务器端的运行环境  

Koa 是一个使用 Node.js 的 web 开发框架，其核心是反复使用的洋葱模型中间件，通过中间件解决 web 开发中的 http 处理、业务逻辑实现  

**介绍下洋葱模型**  

# 介绍下Vue插件的使用,怎么自定义插件/指令,Vue.use()怎么使用？  
Vue.use方法主要做了如下的事：  
* 检查插件是否安装，如果安装了就不再安装  
* 如果没有安装，那么调用插件的install方法，并传入Vue实例    

Vue 自定义指令有全局注册和局部注册两种方式。  
注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。   

指令定义函数提供了几个钩子函数（可选）：
* bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。
* inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。
* update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。
* componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。
* unbind: 只调用一次， 指令与元素解绑时调用。  

![Vue.use](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Vue.use.png)   

# 观察者模式与发布订阅模式  
观察者模式中： 
* 状态发布者维护了一个观察者的列表，明确的知道有哪些观察者存在，将状态变化直接通知给观察者
* 状态的观察者也明确的知道自己观察的状态是描述的哪一个对象
* 甚至需要这种相互知道的关系来处理逻辑（比如需要明确知道哪一个按钮被点击，处理对应的逻辑）

发布订阅模式：  
* 事件的发布者只发布事件，不关心这个事件被谁获取了，通常将事件发给一个中间件，由中间件再去分发事件
* 事件的订阅者只关心事件本身，不关心这个事件是谁发布的，通常在中间件中去注册观察某个事件
* 中间件中去维护事件类别对应的订阅者列表，当收到事件后，去对应列表中通知订阅者们  

[两种模式讲解](https://juejin.cn/post/6844903921211670536)  

## 观察者模式简单实现  

``` 
//被观察者
class Subject{
    constructor(){
        this.arr = []   //存储观察者
        this.state = "开心..."  //存储被观察者状态
    }
    attach(unit){
        this.arr.push(unit)
    }
    //改变状态
    setState(newState){
        this.state = newState
        this.arr.forEach(unit=>unit.update(newState))
    }
}
//观察者
class Observer{
    constructor(name){
        this.name = name
    }
    update(newState){
        console.log(this.name,"状态：",newState);
    }
}
let s = new Subject("宝宝")
let o1 = new Observer("我")
let o2 = new Observer("你")

s.attach(o1)
s.attach(o2)
console.log(s.state);   //开心...
s.setState("不开心...");    //我 状态： 不开心...   你 状态： 不开心...
console.log(s.state);   //不开心...
```  
## 发布订阅简单实现  

``` 
let e = {
    arr:[],
    on(fn){
        this.arr.push(fn)
    },
    emit(){
        this.arr.forEach(fn=>fn())
    }
}
e.on(()=>{
    console.log("哈哈 1");
})
e.on(()=>{
    console.log("哈哈 2");
})

//调一次打印一次
e.emit()    //哈哈 1  哈哈 2  
e.emit()    //哈哈 1  哈哈 2 
```

# 不用all方法实现一个Promise.all功能    

# NaN是什么类型的，在什么情况下会出现？
NaN是属于JavaScript的数值类型Number类型。  
NaN意思是指数据not a number不是一个数字，但是NaN却属于数值类型。  

那么NaN在什么情况下会出现呢？ 

``` 
let a = 'abc'
let b = 5
let c = a * b
console.log(c)
```

# 如果后端返回数据量比较大怎么办？  
从后端的角度：
* 尽量预处理并规整返回的数据：给到合理的数据格式以及需要用作展示的数据，尽量减轻前端的数据处理逻辑。 

从前端的角度：
* 数据传输大，意味着会有较长的网络传输时间，那么最好的方式就是要进行数据缓存。
* 从另外一个角度，可以使用 NodeJS 中间层的方式，不经过浏览器先行请求接口数据并将数据预处理，前端通过调用中间层暴露的接口来调用，浏览器获得的即为中间层处理后的数据，前端可以减轻大量的逻辑处理，拿到的数据可以直接使用，也可以提高页面渲染效率。  
* 当然，渲染是浏览器的事，但是最好也做到按需加载提高性能。  






