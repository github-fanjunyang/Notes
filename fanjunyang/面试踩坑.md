[toc]  



# 性能优化  
* data优化（对象层级不要过深，不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据））  
* 巧妙利用指令v-if(show)，使用v-for要绑定key   
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 缓存和压缩  
* HTTP优化  
* computed 和 watch 区分使用场景
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染   
* 文件压缩，减小资源大小  
* 小图片转base64，减少请求  
* 雪碧图，减少请求  
* 渲染优化（重绘、回流）  
* 减少cookie的使用，减少请求携带大小  



# Node如何创建一个子进程？  

![Node1](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/Node1.png)  

# React的hooks执行原理？  


# 简单介绍下Koa  
NodeJS本质上就是使用JS语言写的解析器，NodeJS给了JS在服务器端的运行环境  

Koa 是一个使用 Node.js 的 web 开发框架，其核心是反复使用的洋葱模型中间件，通过中间件解决 web 开发中的 http 处理、业务逻辑实现  

**介绍下洋葱模型**     

[Express和Koa分析](https://juejin.cn/post/6844903922428035085)  

# Node是如何处理高并发的？  
* eventproxy  
* async.queue  
* async.mapLimit  



# 不用all方法实现一个Promise.all功能    

``` 
function promiseAll(iterable) {
    const array = [...iterable]
    const result = []
    return new Promise((reslove, reject) => {
        for(let i = 0; i < array.length; i++) {
            Promise.resolve(array[i]).then(res => {
                result.push(res)
                result.length === array.length && reslove(result)
            }).catch(reason => {
                reject(reason)
            })
        }
    })
}
```


# 如果后端返回数据量比较大怎么办？  
从后端的角度：
* 尽量预处理并规整返回的数据：给到合理的数据格式以及需要用作展示的数据，尽量减轻前端的数据处理逻辑。 

从前端的角度：
* 数据传输大，意味着会有较长的网络传输时间，那么最好的方式就是要进行数据缓存。
* 从另外一个角度，可以使用 NodeJS 中间层的方式，不经过浏览器先行请求接口数据并将数据预处理，前端通过调用中间层暴露的接口来调用，浏览器获得的即为中间层处理后的数据，前端可以减轻大量的逻辑处理，拿到的数据可以直接使用，也可以提高页面渲染效率。  
* 当然，渲染是浏览器的事，但是最好也做到按需加载提高性能。      
* 用虚拟列表


# Node端如何做实时监控、如何保存日志？      

目前采用PM2做Node进程监控和管理，使用PM2的配置来保存日志输出  

可以使用[log.io](https://github.com/NarrativeScience/log.io)来做服务的实时监控  

# Redux中都有什么方法？有什么中间件来处理Redux?    

[一篇足矣](https://juejin.cn/post/6844903983299952648)  


 # 如果页面中有输入框，刷新后不让输入框数据丢失，怎么做？   
 
 Vuex，Redux 不推荐，localStorage也不合适  
 
 sessionStorage挺合适的
 
 # React怎么保存当前组件的状态？      
**手动保存状态**  
手动保存状态即通过 React 提供的 componentWillUnmount 生命周期通过 redux 之类的状态管理库对数据进行保存，通过 componentDidMount 生命周期进行数据恢复，这也是目前最常见的解决方式，这里不展开讨论。

**通过路由实现状态保存**
由于状态丢失的主要原因是由于路由切换时导致组件被卸载，如果是这样，是否只需要保证组件不被卸载，或者在组件卸载之前将数据状态保存就可以解决我们的问题了，事实上目前社区的相关实现也正是这样。

核心思路：`路由匹配 -> 组件渲染 -> 切换路由 -> 组件卸载 => 路由匹配 -> 组件渲染 -> 切换路由 -> 组件隐藏`  
| 库/功能           | [react-keep-alive](https://github.com/StructureBuilder/react-keep-alive) | [react-keeper](https://github.com/vifird/react-keeper) | [react-router-cache-route](https://github.com/CJY0208/react-router-cache-route) | [react-activation](https://github.com/CJY0208/react-activation/) |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 实现思路          | 将 KeepAlive 的组件藏于其 Provider 中，保证其不会被卸载 -    | 基于 react-router 完全实现一个自定义的路由库           | 改写 react-router 库的 Route 组件，控制渲染行为，使其不被卸载 | 同 react-keep-alive                                          |
| GitHub star       | 407                                                          | 708                                                    | 474                                                          | 217                                                          |
| NPM download      | < 300                                                        | < 200                                                  | ~ 3k                                                         | < 150                                                        |
| 使用方式          | KeepLive                                                     | CacheLink                                              | CacheRoute、CacheSwitch                                      | KeepAlive                                                    |
| Class 生命周期    | componentDidActivate componentWillUnactivate                 | -                                                      | componentDidCache componentDidRecover                        | componentDidActivate componentWillUnactivate                 |
| Function 生命周期 | useKeepAliveEffect                                           | -                                                      | -                                                            | useActivate useUnactivate                                    |
| 恢复滚动位置      | 支持                                                         | 支持                                                   | 支持                                                         | 支持                                                         |
| 缓存控制          | 支持                                                         | -                                                      | 支持（不友好）                                               | 支持                                                         |
| 总结              | ★★★★                                                         | ★★                                                     | ★★                                                           | ★★★★                                                         |
 
，

# OAuth授权认证流程(第三方登录)  

![fanjunyang_book](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/fanjunyang_book.jpg)  


# 自己在封装组件时需要注意哪些点？怎么样才能让组件有更好的适用性？     

* 数据的传入  
  * 数据从父组件传入时应在props中加一些限制或验证   
  * props中的数据不能直接进行修改，如果要引用可进行深拷贝 直接复制不能接触双向绑定  

*  通用组件中的事件处理应尽量放到父组件中 通用组件本身只作为中转，避免数据污染，保证更换的通用性  
*  不要过分依赖Vuex  
*  合理运用scoped编写css，在编写组件的时候，可以在style标签中添加scoped,让标签中的样式只对当前组件生效，但是一味的使用scoped，肯定会产生大量的重复代码，所以在开发的时候，应避免在组件中写样式，当全局样式写好后，再针对每个组件，通过scoped属性添加组件样式  
*  最好留一个slot，为了让通用组件能适用更多场景，应尽量留一个slot以便进行个性化配置 



# React的hooks怎么模拟生命周期  

使用 hooks 模拟 componentDidMount  

``` 
function Example() {
  // 当我们指定第二个参数为空数组就可以代替我们类组件中的componentDidMount
  useEffect(() => {
  	console.log('Did mount!');
  }, []);  
  return <div></div>;
}
```    
使用 hooks 模拟 componentDidUpdate  

``` 
function Example() {
  // 当我们不指定第二个参数的时候就可以代替我们类组件中的componentDidUpdate
  useEffect(() => {
  	console.log('Did update!');
  });  
  return <div></div>;
}
```

使用 hooks 模拟 componentWillUnmount  

``` 
function Example() {
  // 当我们不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount
  useEffect(() => {
  	return () => {
	  console.log('will unmount');  
	}
  });  
  return <div></div>;
}
```  
想通过useEffect模拟componentDidUpdate生命周期，而去掉初次渲染时调用的 componentDidMount    
因为初次渲染只会发生一次，可以使用useRef立一个flag解决：

``` 
let mounting = useRef(true);
useEffect(() => {
	if (mounting.current) {
		console.log("初次")
		mounting.current = false;
		return 
	}
	console.log("DidUpdated")
});
```

useEffect 拥有两个参数，第一个参数作为回调函数会在浏览器布局和绘制完成后调用，因此它不会阻碍浏览器的渲染进程。第二个参数是一个数组
* 当数组存在并有值时，如果数组中的任何值发生更改，则每次渲染后都会触发回调。  
* 当它不存在时，每次渲染后都会触发回调。  
* 当它是一个空列表时，回调只会被触发一次，类似于 componentDidMount。  
* 当不指定第二个参数的同时并在第一个参数中返回一个函数就可以代替我们类组件中的componentWillUnmount  

# React函数组件和类组件区别以及使用场景  


 

# Webpack怎么提高打包速度？  
* 开启多线程打包（thread-loader）  
* 合理利用缓存（cache-loader、HardSourceWebpackPlugin、babel-loader）  
* 分包方式预编译资源模块（DLLPlugin）  
* 缩小构建目标，比如babel-loader不去解析node_modules    
* 1个模块可能有多个方法，只要其中的某个方法使用到了，则整个文件都会被打到 bundle 里面去，tree-shaking 就是只把用到的方法打入 bundle ，没用到的方法会在 uglify 阶段被擦除掉  
* 对图片资源的压缩（image-webpack-loader）  

  


# 谈谈你对前端工程化的理解？  

# 如果给你个项目，你会选择什么框架(Vue或React)?  


# Vuex实现原理(和Redux对比)    


# uniApp中的setData了解过吗？  
  

# 说说对React事件机制的理解    
React基于浏览器的事件机制自身实现了一套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等
在React中这套事件机制被称之为合成事件  

自行[百度](https://www.baidu.com/)
 
 
  

# 什么是死锁？  

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程    

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

* 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。  


* 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。


# 给个1000条数据的列表，用JS动态渲染节点  
一次渲染20条  

# 自定义一个table组件  
动态添加表头等    

# 怎样理解大前端的概念  

