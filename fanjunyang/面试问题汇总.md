[toc]  



本人历经一个月的鏖战，终于斩获了自己心仪的offer，以下是在面试过程中获取的一些经验，希望可以帮到大家，也省去大家搜索资料的过程，其实面试大多时候都是背八股文，没办法，我们只好顺应，如果答案之中有链接的话，最好点进去大致看下。  

> 注意：面试找工作是一个**双向奔赴**的过程，在面试过程中要做到**不卑不亢**  

# 个人介绍  

这个环节非常重要，可以让面试官了解一下你的大致情况，时间控制在1~3min即可，具体可以从以下几个方面介绍：  

* 个人的基本情况（姓名、毕业院校、专业等）
* 工作相关（日常主要负责哪些项目开发、主要使用到哪些技术栈，参与过哪些项目的研发等）  
* 生活相关（性格、兴趣爱好、是否容易相处、学习能力、适应能力等）  
* 其他（可以介绍下自己感兴趣的一些东西，比如：技术，封装过一些类库等）    

示例(可以自己临场发挥)：   

我叫xxx，毕业于xx大学中的xx专业，目前有n年的工作经验。在工作中主要负责xxx系统的日常开发和维护，除了主要负责xxx系统外，也参与过yyy系统的开发，包括也会封装一些常用的组件和方法等，也会做一些后端中间层，包括API接口的开发工作，其中主要使用到的技术找是：例如：Vue、React、Jquery、Zepto、uniApp、Node等等（自由发挥，丰富下自己的语句），在生活中，我是一个乐于助人、幽默开朗、诚实守信、乐观向上、严于律己的一个人，跟同事相处的非常融洽和谐(自己根据[搜索](http://www.360doc.com/content/16/0623/16/34147982_570159625.shtml)内容整理下)，除了日常工作之外，我会看一些书籍(非技术性相关的也可以)来丰富自己的知识、扩展自己的视野，并且经常记一些笔记和写一些技术博客，包括也会自己搭一些框架，做一些自己的项目等。。。这是我个人的一些基本情况，谢谢。

# 技术相关  

俗话说：是骡子是马拉出来溜溜，想要获取一份好工作，只会吹是不行的，必须要有**真才实学**，技术牛皮的话，你想咋样咋样。    

虽然说在工作中主要负责的是前端这一块，但是有些后端的知识也必须了解，这样才能在工作中更加的得心应手，包括前端面试的时候不一定只问前端相关的知识。

以下罗列了一些常见的问题，包括但不限于：    

* HTTP(网络)

* HTML(5) & CSS(3)  
* JS(ES5、ES6、ES7、ES8、ES9、ES10、ES11、ES12等)  
* Vue  
* React  
* 后端(Node、Mysql、Redis等)  
* 运维  
* 常见的算法      
* 项目相关    

> 如果标题上加 ”，表示了解即可，不必强记

## HTTP(网络)   

### 简单说下网络模型“  

参考：[网络七层模型（四层模型）及其区别](https://juejin.cn/post/6844903939918266382)    



### 简单介绍下TCP连接 

TCP的三次握手和四次挥手，为什么一个要三次，一个要四次？  



参考：[TCP 三次握手 与 四次挥手](https://juejin.cn/post/6844903888529653767)  



### 说下TCP与UDP有什么区别？  

![MTCPAndUDP](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MTCPAndUDP.png)



### 从输入一个网址到看到一张网页，经历了什么？  

参考：[从输入一个网址到浏览器显示页面的全过程详细分析](https://juejin.cn/post/6844903888483516430)  



其中的某些过程说的越详细越好，比如拿到数据浏览器是如何渲染到页面上的(HTML树+CSS树=渲染树)  



### 简单说下HTTP协议  

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。    



HTTP协议的特点：  

1.支持客户/服务器模式。支持基本认证和安全认证。

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

4.HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 



HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”(具体内容请参考我的其他文章)。在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。  



HTTP的应用：  

1. 断点续传  
2. 多线程下载  
3. 代理  



参考：[HTTP协议简介](https://juejin.cn/post/6844903888563224583)  



### 了解HTTP中的代理吗？  

**代理服务器的工作流程：**

- 用户向代理发起TCP连接；
- 代理接收用户的连接，双方建立连接；
- 用户向代理发送HTTP请求，请求内容和没有HTTP代理的内容完全相同；
- 代理解析HTTP请求；
- 代理向服务器发起TCP连接；
- 服务器接收代理的连接；
- 代理向服务器发送HTTP请求（这个HTTP请求是基于用户的HTTP请求，可能会有修改）
- 服务器发送响应给代理；

如果不使用代理的话，HTTP的请求报文里会有一个
 `Connection: Keep-Alive`
 如果使用代理的话，HTTP的请求报文里`Connection`就变了
 `Proxy-Connection: Keep-Alive`

**HTTP 代理存在两种形式：普通模式、隧道代理**

- 普通模式

原理：HTTP 客户端向代理服务器发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection:keep-alive），同时向目标服务器发送请求，并将收到的响应转发给客户端。

- 隧道代理

原理：HTTP 客户端通过HTTP的CONNECT方法请求隧道代理，创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。  



### 正向代理与反向代理有什么区别？  

代理可以分为正向代理和反向代理两种。

正向代理需要客户端来配置，一般来说我们会通过浏览器或者操作系统提供的工具或者界面来配置。这个时候，代理对客户端不是透明的，客户端需要知道代理的地址并且手动配置。配置了代理，浏览器在发送请求的时候会对报文做特殊的修改。

反向代理对客户端是透明的，也就是说客户端一般不知道代理的存在，认为自己是直接和服务器通信。我们大部分访问的网站就是反向代理服务器，反向代理服务器会转发到真正的服务器，一般在反向代理这一层实现负载均衡和高可用的功能。而且这里也可以看到，客户端是不会知道真正服务器端的 ip 地址和端口的，这在一定程度上起到了安全保护的作用。



### HTTP状态响应码有哪些？  

罗列一些常见的状态码就行，没必要说那么详细  



参考：[HTTP状态码](https://juejin.cn/post/6844903888563224583#heading-6)   



### HTTP中的请求方法  

HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：

- OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
- HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。
- GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。
- POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- PUT - 向指定资源位置上传其最新内容。
- DELETE - 请求服务器删除Request-URI所标识的资源。
- TRACE- 回显服务器收到的请求，主要用于测试或诊断。
- CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
- PATCH - 用来将局部修改应用于某一资源。



### GET与POST请求有什么区别？  

- 请求参数: GET把参数包含在URL中,用&连接起来; POST通过request body传递参数。
- 请求缓存: GET请求会被主动Cache,而POST请求不会，除非手动设置。
- 收藏为书签: GET请求支持收藏为书签, POST请求不支持。
- 安全性: POST比GET安全, GET请求在浏览器回退时是无害的,而POST会再次请求。
- 历史记录: GET请求参数会被完整保留在浏览历史记录里,而POST中的参数不会被保留。
- 编码方式: GET请求只能进行url编码,而POST支持多种编码方式。
- 参数数据类型: GET只接受ASCIl字符,而POST没有限制数据类型。
- 数据包: GET产生一个TCP数据包; POST可能产生两个TCP数据包。  



### HTTP优化策略  

重点：缓存（强缓存与协商缓存，几乎必问）  

* 强制缓存如果生效，不需要再和服务器发生交互
* 而对比缓存不管是否生效，都需要与服务端发生交互。   

对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。

对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

**两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。**      

**浏览器缓存过程**  

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存（也就是内存中）读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200



**产生的缓存一般放在内存中**  



参考：[HTTP前端性能优化(压缩与缓存)](https://juejin.cn/post/6844903940316725255)



### 说一下web缓存？  
1. web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本    
2. 缓存的好处   
   （1）减少不必要的请求  
   （2）降低服务器的压力，减少服务器的消耗  
   （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）  



### 你知道哪些HTTP的头？  

* 请求头：  
  * `accept-encoding` 告诉服务器，我接收的数据支持压缩格式  
  * `if-modified-since` 对比缓存  修改时间   
  *  `if-none-match` 摘要缓存  和`Etag`配对使用的  
  *  `user-agent` 不同设备自动带上这个头   判断什么样的设备，重定向到不同项目  
* 响应头：  
  * `Content-Type`  告诉浏览器  我给你的内容的类型  
  * `Content-Encoding`  告诉浏览器  我给你的内容的压缩格式   
  * `Cache-Control` 强制缓存  告诉浏览器，你多长时间之间，不要来访问我  
  * `Expires`  强缓   告诉浏览器，你多长时间之间，不要来访问我  
  * `Last-Modified` 对比缓存 和 `if-modified-since` 配对使用  
  * `Etag`   根据摘要做缓存   和 `if-none-match` 配对使用  
  *  `Lotaion`  重定向到 某个地方      



### HTTP和HTTPS有什么区别？  

- HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
- HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。   



HTTPS和HTTP的区别主要如下：
　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



**HTTPS的优点**

1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。  



**HTTPS的缺点（对比优点）**

1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS连接缓存不如HTTP高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

4、HTTPS协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。



### HTTP如何实现长连接？  

- 向的通道,它是可以保持一段时间不关闭的,因此TCP连接才有真正的长连接和短连接这一个说法。
- 长连接是指的是TCP连接,而不是HTTP连接。
- TCP长连接可以复用一个TCP连接来发起多次HTTP请求,这样可以减少资源消耗,比如一次请求HTML,短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接,在响应头设置Connection为keep-alive, HTTP1.1默认是长连接,而HTTP 1.0协议也支持长连接，但是默认是关闭的。  



### HTTP1.X与HTTP2.X有什么区别？  

1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别

2.HTTP2支持多路复用
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求

3.HTTP2头部压缩
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了

4.HTTP2支持服务器推送
HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容  



###  cookie, session，localStorage, sessionStorage有什么区别？  

* cookie 服务器种植的，每次请求都会带上cookie，不安全，解决无状态问题，最多4K，浪费流量  
* session 基于cookie  保存在服务器（内存，入库） 相对安全      
* localStorage 不能跨域存取   最大存5M   超过5M的数据就会丢失   在发送请求时，不会带上localStorage  
* sessionStorage 当浏览器关闭时，里面的数据就丢失  



前后端分离（前端调后端api接口）开发的：cookie，**主流：session 或 JWT**        



参考：[理解cookie、session、localStorage、sessionStorage的关系与区别](https://juejin.cn/post/6844903975800537096)    



### 说下JWT与Session有什么区别和优缺点？  



![MJWTAndSession](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MJWTAndSession.png)



### 说下进程与线程的区别？  

**进程(Process)与线程(Thread)的区别：**

- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
- 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
- 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
- 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
- 一个程序至少有一个进程,一个进程至少有一个线程.
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。



参考：[进程与线程、同步与异步、阻塞与非阻塞、并发与并行](https://juejin.cn/post/6844903848780234759)  



### 进程间的通信方式主要有哪些？    

- 匿名管道
- 命名管道
- 信号量
- 消息队列
- 信号
- 共享内存
- 套接字

从技术上划分又可以划分成以下四种：

1. 消息传递(管道，FIFO，消息队列)
2. 同步(互斥量，条件变量，读写锁等)
3. 共享内存(匿名的，命名的)
4. 远程过程调用



### 说下常见的前端漏洞及防护原理？  

* sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。  
* XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。  
* CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求    



**设置Cookie时如何防止XSS攻击？**  
在服务器端设置cookie的时候设置http-only,这样就可
以防止用户通过JS获取cookie。对cookie的读写或发送
一般有如下字段进行设置:  

 * http-only:只允许http或https请求读取cookie, JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.  
 * secure-only:只允许https请求读取,发送请求时自动发送cookie  
 * host-only:只允许主机域名与domain设置完成一致的网站才能访问该cookie。 



参考：[常见六大Web安全攻防解析](https://juejin.cn/post/6844903772930441230)



## HTML(5)&CSS(3)  



### 说下HTML5都新加了哪些特性？  

HTML5 是定义了 HTML 的标准的最新演进。 这个术语代表了两个不同的概念：

- 它是 HTML 语言的一个新的版本，具有新的元素，属性和行为，
- 以及可以使 Web 站点和应用更加多样化和功能更强大的更丰富的一套技术。 这套技术有时被称作 HTML5 & 它的朋友们 而且往往被缩减到仅是 HTML5。

从要对全部所有的 Web 开发人员有用这一点出发，这个参考页面链接了有关 HTML5 技术的大量资源，并且基于它们各自的功能，把它们归类成了若干组。

- **语义**：能够让你更恰当地描述你的内容是什么。
- **连通性**：能够让你和服务器之间通过创新的新技术方法进行通信。
- **离线 & 存储**：能够让网页在客户端本地存储数据以及更高效地离线运行。
- **多媒体**：使 video 和 audio 成为了在所有 Web 中的一等公民。
- **2D/3D 绘图 & 效果**：提供了一个更加分化范围的呈现选择。
- **性能 & 集成**：提供了非常显著的性能优化和更有效的计算机硬件使用。
- **设备访问 Device Access**：能够处理各种输入和输出设备。
- **样式设计**: 让作者们来创作更加复杂的主题吧。  



### 说下CSS3都新增了哪些特性  

大致说下就行，没必要说那么全。  

在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式(WOFF)也提供了更高的灵活性和控制性。



参考：[CSS3菜鸟教程](https://www.runoob.com/css3/css3-tutorial.html)  



### 说下Flex布局吧  

Flex（Flexible Box）布局 称为 "弹性布局"，可以为网页的布局提供最大的灵活性，取代了往常的 浮动（float） 布局，并且任何一个容器都可以设置 Flex 布局。    

> 注：设置 Flex 布局后，子元素的 Float 布局将失效     

参考： [Flex 布局教程](https://juejin.im/post/5cdfc6ade51d4510a9276955)  



### 说下盒模型

**标准盒子模型和IE盒子模型的区别**

- 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸
- IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。


参考： [CSS 盒子模型](https://juejin.im/post/5d2dbecb6fb9a07eff00bbc3)    



### CSS中link和@import 的区别是什么？  

* link属于HTML标签，而@import是CSS提供的  
* 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载  
* import只在IE5以上才能识别，而link是HTML标签，无兼容问题  
* link方式的样式的权重 高于@import的权重.  



### 说下CSS的优先级  

不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性  

	1. 属性后面加!import 会覆盖页面内任何位置定义的元素样式
	2. 作为style属性写在元素内的样式
	3. id选择器
	4. 类选择器
	5. 标签选择器
	6. 通配符选择器（*）
	7. 浏览器自定义或继承  

**同一级别：后写的会覆盖先写的**



### 说下transition和animation的区别？  

Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，  

而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。



### 理解BFC吗？  

BFC 即 Block Formatting Contexts (块级格式化上下文)。    

具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。    

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 



参考：[理解CSS中的BFC](https://juejin.im/post/5da30040f265da5ba273c47d)    



### 使元素消失的方法有哪些?  

visibility:hidden、display:none、z-index=-1、opacity：0    

1. opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发    

2. visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件    

3. display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉  



### 为什么css放在顶部而js写在后面?  

1. 浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了    
2. 其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。      
3. js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验  



但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面    



### CSS会阻塞页面的加载和渲染吗？  

> 前置问题：js会阻塞DOM树的解析和渲染吗？  
>
> 答： 会  

那么CSS加载会阻塞DOM树的解析和渲染吗？  



首先了解一下浏览器渲染的流程：  

- HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
- 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
- 根据Render Tree渲染绘制，将像素渲染到屏幕上。  

从流程我们可以看出来  

* DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。

* 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。

* 由于js可能会操作之前的DOM节点和CSS，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。



**总结**  

由上所述，我们可以得出以下结论:

- css加载不会阻塞DOM树的解析
- css加载会阻塞DOM树的渲染
- css加载会阻塞后面js语句的执行

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

- 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
- 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
- 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
- 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)



### 说下Less与Sass主要用来做什么？  

Less是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量、继承、运算、函数。

Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行。  



Sass是一种动态样式语言，Sass语法属于缩排语法，比CSS多出好多功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。

Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。

Less和Sass在语法上有些共性，比如下面这些：

1. 混入(Mixins)——class中的class；  
2. 参数混入——可以传递参数的class，就像函数一样；  
3. 嵌套规则——Class中嵌套class，从而减少重复的代码；  
4. 运算——CSS中用上数学；  
5. 颜色功能——可以编辑颜色；  
6. 名字空间(namespace)——分组样式，从而可以被调用；  
7. 作用域——局部修改样式；  
8. JavaScript 赋值——在CSS中使用JavaScript表达式赋值。

Less和Sass的主要不同就是他们的实现方式：  

* Less是基于JavaScript，是在客户端处理的。

* Sass是基于Ruby的，是在服务器端处理的。

关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。



### 说下回流(重排)和重绘吧

当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

* 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少

* 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作  

触发回流的一些情况：

* 页面初次渲染  
* 浏览器窗口大小改变  
* 元素尺寸、位置、内容发生改变  
* 元素字体大小变化  
* 添加或者删除可见的 dom 元素  
* 激活 CSS 伪类（例如：:hover）  
* 查询某些属性或调用某些方法  

```javascript
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()
```



**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。**  



**优化方案：**  

CSS：  

* 避免使用table布局  
* 将动画效果应用到position属性为absolute或fixed的元素上  

JS：  

* 避免频繁操作样式，可汇总后统一 一次修改  
* 尽量使用class进行样式修改  
* 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入  
* 极限优化时，修改样式可将其display: none后修改  
* 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用变量存住    



### 说下BOM与DOM的区别？  

`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 `JavaScript` 有能力与浏览器"对话"。  


`DOM （Document Object Model）`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。 `DOM `是 `W3C`（万维网联盟）的标准。`DOM` 定义了访问 `HTML` 和` XML` 文档的标准： "W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 `W3C DOM` 标准被分为 3 个不同的部分：

- 核心 `DOM` - 针对任何结构化文档的标准模型
- `XML DOM` - 针对 XML 文档的标准模型
- `HTML DOM` - 针对 HTML 文档的标准模型

什么是` XML DOM`？ `XML DOM` 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？ HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法



### href与src有什么区别？  

href是Hypertext Reference的简写，表示超文本**引用**，指向网络资源所在位置。  
常见场景:  

``` 
<a href="http://www.baidu.com"></a> 
<link type="text/css" rel="stylesheet" href="common.css">
```
src是source的简写，目的是要把文件**下载**到html页面中去。  

``` 
<img src="img/girl.jpg"> 
<iframe src="top.html"> 
<script src="show.js">
```
作用结果：  
* href 用于在当前文档和引用资源之间确立联系  
* src 用于替换当前内容    



### 使用REM时给body设置fontSize可以吗？  

> 说下px、em、rem有什么区别？  

这三个的区别是：

* px是固定的像素，一旦设置了就无法因为适应页面大小而改变。  
* em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素<HTML>。**  

但是如果元素自身设置了fontSize，那么em就根据自身进行计算，而不是父元素，如果自身没有设置fontSize，那么就会根据父元素进行设置  





### 实现0.5px的线  

个人感觉是最优解：  

```html
<style>
    .line {
        height: 1px;
        transform: scaleY(0.5);
        transform-origin: 50% 100%;
        background-color: black;
    }
</style>

<body>
    <p>1px + scaleY(0.5)</p>
    <div class='line'></div>
</body>
```



还有一种方法，使用boxshadow：    

这个方法在Chrome和Firefox都非常完美，但是Safari不支持小于1px的boxshadow，所以完全没显示出来。

```html
<style>
    .line {
        height: 1px;
        background: none;
        box-shadow: 0 0.5px 0 #000;
    }
</style>

<body>
    <p>box-shadow: 0 0.5px 0 #000</p>
    <div class='line'></div>
</body>
```



### 如何让一个DIV水平垂直居中？  

```html
<div class="parent">
  <div class="child"></div>
</div>
```

1.   ```css
     div.parent {
         display: flex;
         justify-content: center;
         align-items: center;
     }
     ```

   

2. ```css
   div.parent {
       position: relative; 
   }
   div.child {
       position: absolute; 
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);  
   }
   /* 或者 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       top: 50%;
       left: 50%;
       margin-left: -25px;
       margin-top: -5px;
   }
   /* 或 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       left: 0;
       top: 0;
       right: 0;
       bottom: 0;
       margin: auto;
   }
   ```

3. ```css
   div.parent {
       display: grid;
   }
   div.child {
       justify-self: center;
       align-self: center;
   }
   ```

4. ```css
   div.parent {
       font-size: 0;
       text-align: center;
       &::before {
           content: "";
           display: inline-block;
           width: 0;
           height: 100%;
           vertical-align: middle;
       }
   }
   div.child{
     display: inline-block;
     vertical-align: middle;
   }
   ```

5. ```css
   div.parent{
     display:flex;
   }
   div.child{
     margin:auto;
   }
   ```

6. ```css
   div.parent {
   	display: table;
   }
   div.child {
       display: table-cell
       vertical-align: middle;
       text-align: center;
   }
   ```



### 如何清除浮动？  

 通常在公共的css样式中定义一个清除浮动的类，哪里需要加哪里  

```css
.clearfix{
	clear:both;
	content:'.';
	display:block;
	width: 0;
	height: 0;
	visibility:hidden;
}
```



### 实现一个三栏布局  

三栏布局，顾名思义就是两边固定，中间自适应  



**流体布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    background-color: blue;
	    float: right;
	}
	.main {
	    margin-left: 120px;
	    margin-right: 220px;
	    height: 200px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**BFC**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    margin-right: 20px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    float: right;
	    margin-left: 20px;
	    background-color: blue;
	}	
	.main {
	    height: 200px;
	    overflow: hidden;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**圣杯布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    margin-left: 120px;
	    margin-right: 220px;
	}
	.main {
	    float: left;
	    width: 100%;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    float: left;
	    width: 100px;
	    height: 300px;
	    margin-left: -100%;
	    position: relative;
	    left: -120px;
	    background-color: blue;
	}
	.right {
	    float: left;
	    width: 200px;
	    height: 300px;
	    margin-left: -200px;
	    position: relative;
	    right: -220px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Flex布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
            display: flex;
	}
	.main {
            flex-grow: 1;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    order: -1;
	    flex: 0 1 200px;
	    margin-right: 20px;
	    height: 300px;
	    background-color: blue;
	}
	.right {
	    flex: 0 1 100px;
            margin-left: 20px;
	    height: 300px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Table布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container {
	    display: table;
	    width: 100%;
        }
        .left, .main, .right {
	    display: table-cell;
        }
        .left {
	    width: 200px;
	    height: 300px;
	    background-color: red;
        }
        .main {
	    background-color: blue;
        }
        .right {
	    width: 100px;
	    height: 300px;
	    background-color: green;
        }
    </style>
</head>
<body>
    <div class="container">
	<div class="left"></div>
	<div class="main"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**定位布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    position: relative;
	}
	.main {
	    height: 400px;
	    margin: 0 120px;
	    background-color: green;
	}
	.left {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    left: 0;
	    top: 0;
	    background-color: red;
	}
	.right {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    background-color: blue;
            right: 0;
	    top: 0;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```





## JS  



## Vue  



## React  



## 后端&运维  



## 算法题&手写原理  



## 项目相关  





# 非技术相关   

参考我的文章：[【非技术性问题】](https://juejin.cn/post/6844904008335753224)  

