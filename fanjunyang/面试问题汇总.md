[toc]  



本人历经一个月的鏖战，终于斩获了自己心仪的offer，以下是在面试过程中获取的一些经验，希望可以帮到大家，也省去大家搜索资料的过程，我们只好顺应，如果答案之中有链接的话，最好点进去大致看下。  

> 注意：面试找工作是一个**双向奔赴**的过程，在面试过程中要做到**不卑不亢**  

# 个人介绍  

这个环节非常重要，可以让面试官了解一下你的大致情况，时间控制在1~3min即可，具体可以从以下几个方面介绍：  

* 个人的基本情况（姓名、毕业院校、专业等）
* 工作相关（日常主要负责哪些项目开发、主要使用到哪些技术栈，参与过哪些项目的研发等）  
* 生活相关（性格、兴趣爱好、是否容易相处、学习能力、适应能力等）  
* 其他（可以介绍下自己感兴趣的一些东西，比如：技术，封装过一些类库等）    

示例(可以自己临场发挥)：   

我叫xxx，毕业于xx大学中的xx专业，目前有n年的工作经验。在工作中主要负责xxx系统的日常开发和维护，除了主要负责xxx系统外，也参与过yyy系统的开发，包括也会封装一些常用的组件和方法等，也会做一些后端中间层，包括API接口的开发工作，其中主要使用到的技术找是：例如：Vue、React、Jquery、Zepto、uniApp、Node等等（自由发挥，丰富下自己的语句），在生活中，我是一个乐于助人、幽默开朗、诚实守信、乐观向上、严于律己的一个人，跟同事相处的非常融洽和谐(自己根据[搜索](http://www.360doc.com/content/16/0623/16/34147982_570159625.shtml)内容整理下)，除了日常工作之外，我会看一些书籍(非技术性相关的也可以)来丰富自己的知识、扩展自己的视野，并且经常记一些笔记和写一些技术博客，包括也会自己搭一些框架，做一些自己的项目等。。。这是我个人的一些基本情况，谢谢。

# 技术相关  

俗话说：是骡子是马拉出来溜溜，想要获取一份好工作，只会吹是不行的，必须要有**真才实学**，技术牛皮的话，你想咋样咋样。    

虽然说在工作中主要负责的是前端这一块，但是有些后端的知识也必须了解，这样才能在工作中更加的得心应手，包括前端面试的时候不一定只问前端相关的知识。

以下罗列了一些常见的问题，包括但不限于：    

* HTTP(网络)

* HTML(5) & CSS(3)  
* JS(ES5、ES6、ES7、ES8、ES9、ES10、ES11、ES12等)  
* Vue  
* React  
* 后端(Node、Mysql、Redis等)  
* 运维  
* 常见的算法      
* 项目相关    

> 如果标题上加 ”，表示了解即可，不必强记

## HTTP(网络)   

### 简单说下网络模型“  

参考：[网络七层模型（四层模型）及其区别](https://juejin.cn/post/6844903939918266382)    



### 简单介绍下TCP连接 

TCP的三次握手和四次挥手，为什么一个要三次，一个要四次？  



参考：[TCP 三次握手 与 四次挥手](https://juejin.cn/post/6844903888529653767)  



### 说下TCP与UDP有什么区别？  

![MTCPAndUDP](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MTCPAndUDP.png)



### HTTP中的URI与URL有什么区别？  

**URI 是通用资源标识符，而 URL 是统一资源定位符。**

可以这样理解：

- URI可以表示一个域，也可以表示一个资源。
- URL只能表示一个资源。

因此，笼统地说，每个 URL 都是 URI，但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类，即统一资源名称 URN（Universal Resource Name），它命名资源但不指定如何定位资源（目前没有大规模运用）。



参考：[HTTP中 URI 与 URL 的区别](https://juejin.cn/post/6844903933631004680)



### 从输入一个网址到看到一张网页，经历了什么？  

参考：[从输入一个网址到浏览器显示页面的全过程详细分析](https://juejin.cn/post/6844903888483516430)  



其中的某些过程说的越详细越好，比如拿到数据浏览器是如何渲染到页面上的(HTML树+CSS树=渲染树)  



### 简单说下HTTP协议  

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。    



HTTP协议的特点：  

1.支持客户/服务器模式。支持基本认证和安全认证。

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

4.HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 



HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”(具体内容请参考我的其他文章)。在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。  



HTTP的应用：  

1. 断点续传  
2. 多线程下载  
3. 代理  



参考：[HTTP协议简介](https://juejin.cn/post/6844903888563224583)  



### 了解HTTP中的代理吗？  

**代理服务器的工作流程：**

- 用户向代理发起TCP连接；
- 代理接收用户的连接，双方建立连接；
- 用户向代理发送HTTP请求，请求内容和没有HTTP代理的内容完全相同；
- 代理解析HTTP请求；
- 代理向服务器发起TCP连接；
- 服务器接收代理的连接；
- 代理向服务器发送HTTP请求（这个HTTP请求是基于用户的HTTP请求，可能会有修改）
- 服务器发送响应给代理；

如果不使用代理的话，HTTP的请求报文里会有一个
 `Connection: Keep-Alive`
 如果使用代理的话，HTTP的请求报文里`Connection`就变了
 `Proxy-Connection: Keep-Alive`

**HTTP 代理存在两种形式：普通模式、隧道代理**

- 普通模式

原理：HTTP 客户端向代理服务器发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection:keep-alive），同时向目标服务器发送请求，并将收到的响应转发给客户端。

- 隧道代理

原理：HTTP 客户端通过HTTP的CONNECT方法请求隧道代理，创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。  



### 正向代理与反向代理有什么区别？  

代理可以分为正向代理和反向代理两种。

正向代理需要客户端来配置，一般来说我们会通过浏览器或者操作系统提供的工具或者界面来配置。这个时候，代理对客户端不是透明的，客户端需要知道代理的地址并且手动配置。配置了代理，浏览器在发送请求的时候会对报文做特殊的修改。

反向代理对客户端是透明的，也就是说客户端一般不知道代理的存在，认为自己是直接和服务器通信。我们大部分访问的网站就是反向代理服务器，反向代理服务器会转发到真正的服务器，一般在反向代理这一层实现负载均衡和高可用的功能。而且这里也可以看到，客户端是不会知道真正服务器端的 ip 地址和端口的，这在一定程度上起到了安全保护的作用。



### HTTP状态响应码有哪些？  

罗列一些常见的状态码就行，没必要说那么详细  



参考：[HTTP状态码](https://juejin.cn/post/6844903888563224583#heading-6)   



### HTTP中的请求方法  

HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：

- OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
- HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。
- GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。
- POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- PUT - 向指定资源位置上传其最新内容。
- DELETE - 请求服务器删除Request-URI所标识的资源。
- TRACE- 回显服务器收到的请求，主要用于测试或诊断。
- CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
- PATCH - 用来将局部修改应用于某一资源。



### GET与POST请求有什么区别？  

- 请求参数: GET把参数包含在URL中,用&连接起来; POST通过request body传递参数。
- 请求缓存: GET请求会被主动Cache,而POST请求不会，除非手动设置。
- 收藏为书签: GET请求支持收藏为书签, POST请求不支持。
- 安全性: POST比GET安全, GET请求在浏览器回退时是无害的,而POST会再次请求。
- 历史记录: GET请求参数会被完整保留在浏览历史记录里,而POST中的参数不会被保留。
- 编码方式: GET请求只能进行url编码,而POST支持多种编码方式。
- 参数数据类型: GET只接受ASCIl字符,而POST没有限制数据类型。
- 数据包: GET产生一个TCP数据包; POST可能产生两个TCP数据包。  



### HTTP优化策略(缓存)  

重点：缓存（强缓存与协商缓存，几乎必问）  

* 强制缓存如果生效，不需要再和服务器发生交互
* 而对比缓存不管是否生效，都需要与服务端发生交互。   

对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。

对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

**两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。**      

**浏览器缓存过程**  

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存（也就是内存中）读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200



**产生的缓存一般放在内存中**  



参考：[HTTP前端性能优化(压缩与缓存)](https://juejin.cn/post/6844903940316725255)



### 说一下web缓存？  
1. web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本    
2. 缓存的好处   
   （1）减少不必要的请求  
   （2）降低服务器的压力，减少服务器的消耗  
   （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）  



### 你知道哪些HTTP的头？  

* 请求头：  
  * `accept-encoding` 告诉服务器，我接收的数据支持压缩格式  
  * `if-modified-since` 对比缓存  修改时间   
  *  `if-none-match` 摘要缓存  和`Etag`配对使用的  
  *  `user-agent` 不同设备自动带上这个头   判断什么样的设备，重定向到不同项目  
* 响应头：  
  * `Content-Type`  告诉浏览器  我给你的内容的类型  
  * `Content-Encoding`  告诉浏览器  我给你的内容的压缩格式   
  * `Cache-Control` 强制缓存  告诉浏览器，你多长时间之间，不要来访问我  
  * `Expires`  强缓   告诉浏览器，你多长时间之间，不要来访问我  
  * `Last-Modified` 对比缓存 和 `if-modified-since` 配对使用  
  * `Etag`   根据摘要做缓存   和 `if-none-match` 配对使用  
  *  `Lotaion`  重定向到 某个地方      



### HTTP和HTTPS有什么区别？  

- HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
- HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。   



HTTPS和HTTP的区别主要如下：
　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



**HTTPS的优点**

1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。  



**HTTPS的缺点（对比优点）**

1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS连接缓存不如HTTP高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

4、HTTPS协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。



### HTTP如何实现长连接？  

- 向的通道,它是可以保持一段时间不关闭的,因此TCP连接才有真正的长连接和短连接这一个说法。
- 长连接是指的是TCP连接,而不是HTTP连接。
- TCP长连接可以复用一个TCP连接来发起多次HTTP请求,这样可以减少资源消耗,比如一次请求HTML,短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接,在响应头设置Connection为keep-alive, HTTP1.1默认是长连接,而HTTP 1.0协议也支持长连接，但是默认是关闭的。  



### HTTP1.X与HTTP2.X有什么区别？  

1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别

2.HTTP2支持多路复用
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求

3.HTTP2头部压缩
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了

4.HTTP2支持服务器推送
HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容  



###  cookie, session，localStorage, sessionStorage有什么区别？  

* cookie 服务器种植的，每次请求都会带上cookie，不安全，解决无状态问题，最多4K，浪费流量  
* session 基于cookie  保存在服务器（内存，入库） 相对安全      
* localStorage 不能跨域存取   最大存5M   超过5M的数据就会丢失   在发送请求时，不会带上localStorage  
* sessionStorage 当浏览器关闭时，里面的数据就丢失  



前后端分离（前端调后端api接口）开发的：cookie，**主流：session 或 JWT**        



参考：[理解cookie、session、localStorage、sessionStorage的关系与区别](https://juejin.cn/post/6844903975800537096)    



### 说下JWT与Session有什么区别和优缺点？  



![MJWTAndSession](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MJWTAndSession.png)



### OAuth授权认证流程是什么？  

OAuth被广泛用于第三方登录，例如微信小程序等，主要用来获取用户的信息，流程：  



![MOAuth](D:\桌面\MOAuth.png)



### 什么是单点登录？怎么实现？  

单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一
SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统
SSO 一般都需要一个独立的认证中心（passport），子系统的登录均得通过passport，子系统本身将不参与登录操作
当一个系统成功登录以后，passport将会颁发一个令牌给各个子系统，子系统可以拿着令牌会获取各自的受保护资源，为了减少频繁认证，各个子系统在被passport授权以后，会建立一个局部会话，在一定时间内可以无需再次向passport发起认证  

举例：    

淘宝、天猫都属于阿里旗下，当用户登录淘宝后，再打开天猫，系统便自动帮用户登录了天猫，这种现象就属于单点登录    



![singledian](D:\桌面\singledian.png)





### 说下进程与线程的区别？  

**进程(Process)与线程(Thread)的区别：**

- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
- 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
- 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
- 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
- 一个程序至少有一个进程,一个进程至少有一个线程.
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。



参考：[进程与线程、同步与异步、阻塞与非阻塞、并发与并行](https://juejin.cn/post/6844903848780234759)  



### 进程间的通信方式主要有哪些？    

- 匿名管道
- 命名管道
- 信号量
- 消息队列
- 信号
- 共享内存
- 套接字

从技术上划分又可以划分成以下四种：

1. 消息传递(管道，FIFO，消息队列)
2. 同步(互斥量，条件变量，读写锁等)
3. 共享内存(匿名的，命名的)
4. 远程过程调用



### 如何理解CDN？  

CDN (全称 Content Delivery Network)，即内容分发网络

构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。`CDN` 的关键技术主要有内容存储和分发技术

简单来讲，`CDN`就是根据用户位置分配最近的资源

于是，用户在上网的时候不用直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**，其实就是缓存了源站内容的代理服务器。  



**实现CDN的关键点**  

* 负载均衡系统  
* 缓存代理    



**为什么使用CDN？**  

`CDN` 目的是为了改善互联网的服务质量，通俗一点说其实就是提高访问速度

`CDN` 构建了全国、全球级别的专网，让用户就近访问专网里的边缘节点，降低了传输延迟，实现了网站加速

通过`CDN`的负载均衡系统，智能调度边缘节点提供服务，相当于`CDN`服务的大脑，而缓存系统相当于`CDN`的心脏，缓存命中直接返回给用户，否则回源  



### 说说你对WebSocket的理解？  

WebSocket，是一种网络传输协议，位于`OSI`模型的应用层。可在单个`TCP`连接上进行全双工通信，能更好的节省服务器资源和带宽并达到实时通迅

客户端和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输  



`websocket`服务器与客户端通过握手连接，连接成功后，**两者都能主动的向对方发送或接受数据**（服务端主要推动消息的关键点，现在的聊天功能的就是基于这个实现的）  



而在`websocket`出现之前，开发实时`web`应用的方式为轮询

不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果

轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 `CPU`资源  



**特点：**  

* 全双工通信  
* 二进制帧  
* 协议名(ws、wss)  
* 握手(一次)  



**优点：**  

- 较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部
- 更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少
- 保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证
- 更好的二进制支持：定义了二进制帧，更好处理二进制内容
- 支持扩展：用户可以扩展websocket协议、实现部分自定义的子协议
- 更好的压缩效果：Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率  



**应用场景：**  

- 弹幕
- 媒体聊天
- 协同编辑
- 基于位置的应用
- 体育实况更新
- 股票基金报价实时更新



### 说下常见的前端漏洞及防护原理？  

* sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。  
* XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。  
* CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求    



**设置Cookie时如何防止XSS攻击？**  
在服务器端设置cookie的时候设置http-only,这样就可
以防止用户通过JS获取cookie。对cookie的读写或发送
一般有如下字段进行设置:  

 * http-only:只允许http或https请求读取cookie, JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.  
 * secure-only:只允许https请求读取,发送请求时自动发送cookie  
 * host-only:只允许主机域名与domain设置完成一致的网站才能访问该cookie。 



参考：[常见六大Web安全攻防解析](https://juejin.cn/post/6844903772930441230)



## HTML(5)&CSS(3)  



### 说下HTML5都新加了哪些特性？  

HTML5 是定义了 HTML 的标准的最新演进。 这个术语代表了两个不同的概念：

- 它是 HTML 语言的一个新的版本，具有新的元素，属性和行为，
- 以及可以使 Web 站点和应用更加多样化和功能更强大的更丰富的一套技术。 这套技术有时被称作 HTML5 & 它的朋友们 而且往往被缩减到仅是 HTML5。

从要对全部所有的 Web 开发人员有用这一点出发，这个参考页面链接了有关 HTML5 技术的大量资源，并且基于它们各自的功能，把它们归类成了若干组。

- **语义**：能够让你更恰当地描述你的内容是什么。
- **连通性**：能够让你和服务器之间通过创新的新技术方法进行通信。
- **离线 & 存储**：能够让网页在客户端本地存储数据以及更高效地离线运行。
- **多媒体**：使 video 和 audio 成为了在所有 Web 中的一等公民。
- **2D/3D 绘图 & 效果**：提供了一个更加分化范围的呈现选择。
- **性能 & 集成**：提供了非常显著的性能优化和更有效的计算机硬件使用。
- **设备访问 Device Access**：能够处理各种输入和输出设备。
- **样式设计**: 让作者们来创作更加复杂的主题吧。  



### 说下CSS3都新增了哪些特性  

大致说下就行，没必要说那么全。  

在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式(WOFF)也提供了更高的灵活性和控制性。



参考：[CSS3菜鸟教程](https://www.runoob.com/css3/css3-tutorial.html)  



### 说下Flex布局吧  

Flex（Flexible Box）布局 称为 "弹性布局"，可以为网页的布局提供最大的灵活性，取代了往常的 浮动（float） 布局，并且任何一个容器都可以设置 Flex 布局。    

> 注：设置 Flex 布局后，子元素的 Float 布局将失效     

参考： [Flex 布局教程](https://juejin.im/post/5cdfc6ade51d4510a9276955)  



### 说下盒模型

**标准盒子模型和IE盒子模型的区别**

- 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸
- IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。


参考： [CSS 盒子模型](https://juejin.im/post/5d2dbecb6fb9a07eff00bbc3)    



### CSS中link和@import 的区别是什么？  

* link属于HTML标签，而@import是CSS提供的  
* 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载  
* import只在IE5以上才能识别，而link是HTML标签，无兼容问题  
* link方式的样式的权重 高于@import的权重.  



### 说下CSS的优先级  

不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性  

	1. 属性后面加!import 会覆盖页面内任何位置定义的元素样式
	2. 作为style属性写在元素内的样式
	3. id选择器
	4. 类选择器
	5. 标签选择器
	6. 通配符选择器（*）
	7. 浏览器自定义或继承  

**同一级别：后写的会覆盖先写的**



### 说下transition和animation的区别？  

Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，  

而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。



### 理解BFC吗？  

BFC 即 Block Formatting Contexts (块级格式化上下文)。    

具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。    

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 



参考：[理解CSS中的BFC](https://juejin.im/post/5da30040f265da5ba273c47d)    



### 使元素消失的方法有哪些?  

visibility:hidden、display:none、z-index=-1、opacity：0    

1. opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发    

2. visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件    

3. display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉  



### 为什么css放在顶部而js写在后面?  

1. 浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了    
2. 其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。      
3. js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验  



但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面    



### CSS会阻塞页面的加载和渲染吗？  

> 前置问题：js会阻塞DOM树的解析和渲染吗？  
>
> 答： 会  

那么CSS加载会阻塞DOM树的解析和渲染吗？  



首先了解一下浏览器渲染的流程：  

- HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
- 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
- 根据Render Tree渲染绘制，将像素渲染到屏幕上。  

从流程我们可以看出来  

* DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。

* 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。

* 由于js可能会操作之前的DOM节点和CSS，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。



**总结**  

由上所述，我们可以得出以下结论:

- css加载不会阻塞DOM树的解析
- css加载会阻塞DOM树的渲染
- css加载会阻塞后面js语句的执行

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

- 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
- 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
- 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
- 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)



### 说下Less与Sass主要用来做什么？  

Less是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量、继承、运算、函数。

Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行。  



Sass是一种动态样式语言，Sass语法属于缩排语法，比CSS多出好多功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。

Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。

Less和Sass在语法上有些共性，比如下面这些：

1. 混入(Mixins)——class中的class；  
2. 参数混入——可以传递参数的class，就像函数一样；  
3. 嵌套规则——Class中嵌套class，从而减少重复的代码；  
4. 运算——CSS中用上数学；  
5. 颜色功能——可以编辑颜色；  
6. 名字空间(namespace)——分组样式，从而可以被调用；  
7. 作用域——局部修改样式；  
8. JavaScript 赋值——在CSS中使用JavaScript表达式赋值。

Less和Sass的主要不同就是他们的实现方式：  

* Less是基于JavaScript，是在客户端处理的。

* Sass是基于Ruby的，是在服务器端处理的。

关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。



### 说下回流(重排)和重绘吧

当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

* 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少

* 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作  

触发回流的一些情况：

* 页面初次渲染  
* 浏览器窗口大小改变  
* 元素尺寸、位置、内容发生改变  
* 元素字体大小变化  
* 添加或者删除可见的 dom 元素  
* 激活 CSS 伪类（例如：:hover）  
* 查询某些属性或调用某些方法  

```javascript
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()
```



**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。**  



**优化方案：**  

CSS：  

* 避免使用table布局  
* 将动画效果应用到position属性为absolute或fixed的元素上  

JS：  

* 避免频繁操作样式，可汇总后统一 一次修改  
* 尽量使用class进行样式修改  
* 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入  
* 极限优化时，修改样式可将其display: none后修改  
* 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用变量存住    



### 说下BOM与DOM的区别？  

`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 `JavaScript` 有能力与浏览器"对话"。  


`DOM （Document Object Model）`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。 `DOM `是 `W3C`（万维网联盟）的标准。`DOM` 定义了访问 `HTML` 和` XML` 文档的标准： "W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 `W3C DOM` 标准被分为 3 个不同的部分：

- 核心 `DOM` - 针对任何结构化文档的标准模型
- `XML DOM` - 针对 XML 文档的标准模型
- `HTML DOM` - 针对 HTML 文档的标准模型

什么是` XML DOM`？ `XML DOM` 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？ HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法



### href与src有什么区别？  

href是Hypertext Reference的简写，表示超文本**引用**，指向网络资源所在位置。  
常见场景:  

``` 
<a href="http://www.baidu.com"></a> 
<link type="text/css" rel="stylesheet" href="common.css">
```
src是source的简写，目的是要把文件**下载**到html页面中去。  

``` 
<img src="img/girl.jpg"> 
<iframe src="top.html"> 
<script src="show.js">
```
作用结果：  
* href 用于在当前文档和引用资源之间确立联系  
* src 用于替换当前内容    



### 使用REM时给body设置fontSize可以吗？  

> 说下px、em、rem有什么区别？  

这三个的区别是：

* px是固定的像素，一旦设置了就无法因为适应页面大小而改变。  
* em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素<HTML>。**  

但是如果元素自身设置了fontSize，那么em就根据自身进行计算，而不是父元素，如果自身没有设置fontSize，那么就会根据父元素进行设置  





### 实现0.5px的线  

个人感觉是最优解：  

```html
<style>
    .line {
        height: 1px;
        transform: scaleY(0.5);
        transform-origin: 50% 100%;
        background-color: black;
    }
</style>

<body>
    <p>1px + scaleY(0.5)</p>
    <div class='line'></div>
</body>
```



还有一种方法，使用boxshadow：    

这个方法在Chrome和Firefox都非常完美，但是Safari不支持小于1px的boxshadow，所以完全没显示出来。

```html
<style>
    .line {
        height: 1px;
        background: none;
        box-shadow: 0 0.5px 0 #000;
    }
</style>

<body>
    <p>box-shadow: 0 0.5px 0 #000</p>
    <div class='line'></div>
</body>
```



### 如何让一个DIV水平垂直居中？  

```html
<div class="parent">
  <div class="child"></div>
</div>
```

1.   ```css
     div.parent {
         display: flex;
         justify-content: center;
         align-items: center;
     }
     ```

   

2. ```css
   div.parent {
       position: relative; 
   }
   div.child {
       position: absolute; 
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);  
   }
   /* 或者 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       top: 50%;
       left: 50%;
       margin-left: -25px;
       margin-top: -5px;
   }
   /* 或 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       left: 0;
       top: 0;
       right: 0;
       bottom: 0;
       margin: auto;
   }
   ```

3. ```css
   div.parent {
       display: grid;
   }
   div.child {
       justify-self: center;
       align-self: center;
   }
   ```

4. ```css
   div.parent {
       font-size: 0;
       text-align: center;
       &::before {
           content: "";
           display: inline-block;
           width: 0;
           height: 100%;
           vertical-align: middle;
       }
   }
   div.child{
     display: inline-block;
     vertical-align: middle;
   }
   ```

5. ```css
   div.parent{
     display:flex;
   }
   div.child{
     margin:auto;
   }
   ```

6. ```css
   div.parent {
   	display: table;
   }
   div.child {
       display: table-cell
       vertical-align: middle;
       text-align: center;
   }
   ```



### 如何清除浮动？  

 通常在公共的css样式中定义一个清除浮动的类，哪里需要加哪里  

```css
.clearfix{
	clear:both;
	content:'.';
	display:block;
	width: 0;
	height: 0;
	visibility:hidden;
}
```



### 实现一个三栏布局  

三栏布局，顾名思义就是两边固定，中间自适应  



**流体布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    background-color: blue;
	    float: right;
	}
	.main {
	    margin-left: 120px;
	    margin-right: 220px;
	    height: 200px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**BFC**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    margin-right: 20px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    float: right;
	    margin-left: 20px;
	    background-color: blue;
	}	
	.main {
	    height: 200px;
	    overflow: hidden;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**圣杯布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    margin-left: 120px;
	    margin-right: 220px;
	}
	.main {
	    float: left;
	    width: 100%;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    float: left;
	    width: 100px;
	    height: 300px;
	    margin-left: -100%;
	    position: relative;
	    left: -120px;
	    background-color: blue;
	}
	.right {
	    float: left;
	    width: 200px;
	    height: 300px;
	    margin-left: -200px;
	    position: relative;
	    right: -220px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Flex布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
            display: flex;
	}
	.main {
            flex-grow: 1;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    order: -1;
	    flex: 0 1 200px;
	    margin-right: 20px;
	    height: 300px;
	    background-color: blue;
	}
	.right {
	    flex: 0 1 100px;
            margin-left: 20px;
	    height: 300px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Table布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container {
	    display: table;
	    width: 100%;
        }
        .left, .main, .right {
	    display: table-cell;
        }
        .left {
	    width: 200px;
	    height: 300px;
	    background-color: red;
        }
        .main {
	    background-color: blue;
        }
        .right {
	    width: 100px;
	    height: 300px;
	    background-color: green;
        }
    </style>
</head>
<body>
    <div class="container">
	<div class="left"></div>
	<div class="main"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**定位布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    position: relative;
	}
	.main {
	    height: 400px;
	    margin: 0 120px;
	    background-color: green;
	}
	.left {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    left: 0;
	    top: 0;
	    background-color: red;
	}
	.right {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    background-color: blue;
            right: 0;
	    top: 0;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



### z-index有最大最小值吗？    

答：有，不同浏览器取值可能不同  

- 原理：

  当两个同父元素z-index相同时，后面的元素显示在上面。

  当z-index超过浏览器最大值时，浏览器会按最大值计算。  

* 汇总  

|        | ver.    | max        | min         | typeof(div.style.zIndex) |
| ------ | ------- | ---------- | ----------- | ------------------------ |
| IE     | 8.0     | 2147483647 | -2147483648 | number                   |
| Chrome | 3.0.195 | 2147483647 | -2147483648 | string                   |
| FF     | 3.5.7   | 2147483645 | -2147483647 | string                   |
| Opera  | 10.10   | 2147483584 | -2147483584 | string                   |

- 结论：

  当需要兼容以上所有浏览器时，z-index需使用 -2147483584 ~ 2147483584 范围内的数字



## JS  

前端面试的重中之重，面试的好不好就看你JS玩不6不6  



### JS中的数据类型有哪些？  

八种，分别是：string、number、boolean、undefined、null、symbol(ES6)、bigint(ES10)和object  



> 然后应该会问怎么判断这些数据类型？  

使用typeof、instanceof、原型  



typeof主要用来判断基本数据类型  

instanceof主要用来判断引用数据类型  



不过最好使用原型上的方法判断，是最准确的，写个方法：  

```javascript
function checkType(para) {
    return Object.prototype.toString.call(para).slice(8,-1)  
}
```



### 说下JS中你都用过哪些方法？  

点进去看看：[JS中常用方法总结](https://juejin.cn/post/6844903898189152263)

 

> 追问：说下forEach与Map的区别？  

forEach没有return  

Map可以return，从而组成一个新的数组



### NaN是什么类型的，在什么情况下会出现？  

NaN是属于JavaScript的数值类型Number类型。  
NaN意思是指数据not a number不是一个数字，但是NaN却属于数值类型。  

那么NaN在什么情况下会出现呢？  

```javascript
let a = 'abc'
let b = 5
let c = a * b
console.log(c)

console.log(NaN === NaN) // false
```



### for...in...与for...of...有什么区别？  

for...in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。像 Array和Object使用内置构造函数所创建的对象都会继承自Object.prototype和String.prototype的不可枚举属性，例如 String 的 indexOf()  方法或 Object的toString()方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。  

for...of语句在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句  

无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
* for...in语句以任意顺序迭代对象的可枚举属性。  
* for...of 语句遍历可迭代对象定义要迭代的数据。    

总结：  
for in 一般用来遍历对象的key、for of 一般用来遍历数组的value  
for … in

* for … in 获取的是对象的键名;
* for … in会遍历对象的整个原型链,性能非常差不推荐使用;
* 对于数组的遍历,for … in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性);  


for … of
* for … of遍历获取的是对象的键值;
* for … of只遍历当前对象不会遍历原型链;
* 对于数组的遍历,for … of只返回数组的下标对应的属性值;



### 怎么结束for、forEach、Map循环？怎么跳出本轮循环、整个循环和嵌套循环？  

**return语句的作用**  

(1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行
(2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致，可以使用强制类型转换来是数据类型一致
(3) return 当方法说明中用void声明返回类型为空时，应使用这种格式，不返回任何值。  



**break语句的作用**  

(1) 只能在循环体内和switch语句体内使用break语句。
(2) 当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。
(3) 当break出现在循环体中，但并不在switch语句体内时，则在执行break后，跳出本层循环体。
(4) 在循环结构中，应用break语句使流程跳出本层循环体，从而提前结束本层循环  



**continue语句作用**  

(1) continue语句的一般形式为：continue;
(2) 其作用是结束本次循环，即跳过本次循环体中余下尚未执行的语句，接着再一次进行循环的条件判定。
(3) 注意：执行continue语句并没有使整个循环终止。在while和do-while循环中，continue语句使得流程直接跳到循环控制条件的测试部分 ，然后决定循环是否继续进行。
(4) 在for 循环中，遇到continue后，跳过循环体中余下的语句，而去对for语句中的“表达式3”求值，然后进行“表达式2”的条件测试，



### JS中实现页面跳转和刷新方法有哪些？  



参考：[JS中实现页面跳转和刷新方法总结](https://juejin.cn/post/6844903925741682696)    



### 说下JS中的事件模型和事件流    

**事件与事件流**  

`javascript`中的事件，可以理解就是在`HTML`文档或者浏览器中发生的一种交互操作，使得网页具备互动性， 常见的有加载事件、鼠标事件、自定义事件等

由于`DOM`是一个树结构，如果在父子节点绑定事件时候，当触发子节点的时候，就存在一个顺序问题，这就涉及到了事件流的概念

事件流都会经历三个阶段：

- 事件捕获阶段(capture phase)
- 处于目标阶段(target phase)
- 事件冒泡阶段(bubbling phase)  



![JSEvent](D:\桌面\JSEvent.png)

**事件模型**  

事件模型可以分为三种：

- 原始事件模型（DOM0级）
- 标准事件模型（DOM2级）
- IE事件模型（基本不用）  



原始事件模型的特性：  

* 绑定速度快  
* 只支持冒泡，不支持捕获  
* 同一个类型的事件只能绑定一次



在标准事件模型中，一次事件共有三个过程:

- 事件捕获阶段：事件从`document`一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行
- 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数
- 事件冒泡阶段：事件从目标元素冒泡到`document`, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



IE事件模型共有两个过程:

- 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数。
- 事件冒泡阶段：事件从目标元素冒泡到`document`, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行



### `==`与`===`的区别，是否`===`就完全靠谱？  

不一定靠谱，例如 `0 === -0`就为true，`NaN === NaN`为false，判断两个变量是否完全相等可以使用ES6新增的API，`Object.is(0, -0)`，就可以准确区分  



### JS的异步解决方案有哪些？  

* 回调函数（嵌套，回调地狱，不优雅）  
* Promise    
* Generator+co （co可以解决promise嵌套问题）  
* async+await：是Generator的语法糖    

**其实Generator和async+await本质上还是基于Promise实现的**  



参考：  

[JS中的异步解决方案](https://juejin.cn/post/6844903896486264845)  

[深入理解 promise、generator+co、async/await 用法](https://juejin.cn/post/6844903919554920461)    



### 说下Promise的实现原理  

手写Promise，后面《手写原理》会有，看后面  



### 关于Promise.then的链式调用问题  

> then可以链式调用，多个then时，如何走到下一个then的失败回调？  

答：  

1.返回一个失败的promise。  

2.抛出一个错误(throw new Error())    



> then可以链式调用，多个then时，如何终止下一个then的调用？  

答：  

返回一个处于pending(等待态)状态的promise



### 如何把一个伪数组转变为真实的数组？  

* 使用ES6中的展开运算符（ [...obj]，需要保证obj是可迭代的 ）  
* Array.from不需要保证obj是否迭代，内部会使它可迭代     
* 自定义一个genertor迭代器  



### 你都使用过ES6中的哪些语法？  

* let、const  
* 解构赋值  
* 展开运算符  
* 字符串、对象和数组中新加的方法(例：repeat、fill、flat)  
* Set和Map  
* Symbol  
* 箭头函数  
* Reflect和Proxy  
* Class  
* 模块化  
* Promise  

参考：[ES6 新增内容总结](https://juejin.cn/post/6844903902031118344)  



### var、let、const有什么区别？  



点击看下：[区别](https://juejin.cn/post/6844903902031118344#heading-0)  



> 做道题  

```javascript
for(var i=0; i<5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}

// 输出结果是啥  
// 1S 后输出5个5
```

那么我怎么才能按顺序输出0，1，2，3，4呢？  



使用let关键字  

```javascript
for(let i=0; i<5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}

// 输出结果：0,1,3,4,5
```

为什么使用let关键字可以？  

答：因为他会形成一个块级作用域  



如果不适用let关键字怎么解决呢？  

```javascript
for(var i=0; i<5; i++) {
    ((i) => {
        setTimeout(() => {
            console.log(i);
        }, 1000)
    })(i)
}

// 自己形成块级作用域即可
```



### 说下ES6中的模块化  



[点我](https://juejin.im/post/5d3eb1b6f265da03c23eacc2#heading-44)  



### 说下JS中的闭包以及应用场景  

什么是闭包？  

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。  



1. 优点
* 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用  
* 避免变量污染全局    
* 把变量存到独立的作用域，作为私有成员存在
2. 缺点
* 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏  
* 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度  
* 可能获取到意外的值(captured value)  

应用场景：  

* 函数防抖节流  
* 函数柯里化  
* 使用闭包设计单例模式  
* 为多个组件设置独立属性  
* 设置私有变量  
* 拿到正确的值  



### 堆和栈有什么区别？  

堆中存的是引用数据类型，是动态分配的内存，大小不定也不会自动释放；  

栈中存的是基本数据类型，会自动分配内存空间，自动释放；



- 堆(heap):也可以叫堆内存；是一种队列优先，先进先出的数据结构；
- 栈(stack):又名'堆栈',也是一种数据结构，不过它是按照先进后出原则存储数据的。  




使用JS代码实现队列和栈的功能（就是用数组的增删方法）：  

- 实现队列的方法（先进先出）

```
let arr = new Array();
arr.push(1);
arr.push(2);
arr.shift();
复制代码
```

- 实现栈的方法（先进后出）

```
let arr = new Array();
arr.push(1);
arr.push(2);
arr.pop();
```



### JS深拷贝与浅拷贝的区别？  

**浅拷贝**  

只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；

简单的说，浅拷贝就是将一个对象的内存地址的“”编号“”复制给另一个对象。即在真正访问的时候还是会访问到被复制对象。 或者只是深拷贝了第一层的引用类型，而没有拷贝更深层次的应用类型，而是利用复制地址的方式，这也是浅拷贝。

**深拷贝**  

复制并创建一个一模一样的对象，不共享内存，修改新对象，旧对象保持不变。

简单的说，深拷贝就是先新建一个空对象，内存中新开辟一块地址，把被复制对象的所有可枚举的(注意可枚举的对象)属性方法一一复制过来，注意要用递归来复制子对象里面的所有属性和方法，直到子子.....属性为基本数据类型。
 **关键点：开辟新内存、递归复制。**



> 实现一个深拷贝  

```javascript
// 深拷贝
function deepClone(source) {
    // 判断复制的目标是数组还是对象
    const target = source.constructor === Array ? [] : {}
    // 遍历目标
    for (const key in source) {
        if (source[key] && typeof source[key] === 'object') {
            // 对象 || 数组
            target[key] = source[key].constructor === Array ? [] : {}
            target[key] = deepClone(source[key])
        } else {
            // 不是对象或者数组，直接赋值
            target[key] = source[key]
        }
    }
    return target
}
```



参考：[理解JS中的浅拷贝与深拷贝](https://juejin.cn/post/6844903962424934407)





### 说下EventLoop(事件环)  



[JS(浏览器)事件环 (宏、微任务)](https://juejin.cn/post/6844903914085564423)  



### 说下JS中的原型和原型链  

参考：[JavaScript 原型 与 原型链](https://juejin.cn/post/6844903914085564423)  



```javascript
function A() {}
let a = new A()

// console.log(a.__proto__ == A.prototype) // true

// console.log(A.prototype.__proto__ == Object.prototype)  // true

// console.log(Object.prototype.__proto__ == null)  // true

// console.log(A.prototype.constructor == A)   // true
```



### 说下JS中的作用域和作用域链  



参考：[JavaScript 作用域 与 作用域链](https://juejin.cn/post/6844903901074980871)  



### JS中new做了什么？  

- 创建了一个空对象
- 绑定this值
- 链接到原型
- 返回新对象  



参考：[JS中 new究竟做了什么？](https://juejin.cn/post/6844903896326864910)  



### 说下箭头函数和普通函数有什么区别？  

主要区别就是this关键字的问题  

箭头函数中没有this  

**箭头函数中谁调用了包含this的方法，那么this就指向谁**      



> 这时候十有八九会让你做道题，后面做题环节再试下  



### 怎么改变this的指向？  



参考：[JS中改变this的指向 call、apply 和 bind 的区别](https://juejin.cn/post/6844903895743856654)  



### JS常见的设计模式"  

* 构造函数设计模式  
* 原型模式  
* 模块设计模式  
* 单例模式  
* 工厂模式  
* 观察者模式  
* 命令模式  
* 装饰模式  
* MVC模式  
* MVVM模式    



### 观察者模式和发布订阅模式有什么区别？  



观察者模式中： 
* 状态发布者维护了一个观察者的列表，明确的知道有哪些观察者存在，将状态变化直接通知给观察者
* 状态的观察者也明确的知道自己观察的状态是描述的哪一个对象
* 甚至需要这种相互知道的关系来处理逻辑（比如需要明确知道哪一个按钮被点击，处理对应的逻辑）

发布订阅模式：  
* 事件的发布者只发布事件，不关心这个事件被谁获取了，通常将事件发给一个中间件，由中间件再去分发事件
* 事件的订阅者只关心事件本身，不关心这个事件是谁发布的，通常在中间件中去注册观察某个事件
* 中间件中去维护事件类别对应的订阅者列表，当收到事件后，去对应列表中通知订阅者们  

参考：[两种模式讲解](https://juejin.cn/post/6844903921211670536)    



> 追问：能给我简单实现这两种模式吗？  

**观察者模式简单实现**

```javascript
//被观察者
class Subject{
    constructor(){
        this.arr = []   //存储观察者
        this.state = "开心..."  //存储被观察者状态
    }
    attach(unit){
        this.arr.push(unit)
    }
    //改变状态
    setState(newState){
        this.state = newState
        this.arr.forEach(unit=>unit.update(newState))
    }
}
//观察者
class Observer{
    constructor(name){
        this.name = name
    }
    update(newState){
        console.log(this.name,"状态：",newState);
    }
}
let s = new Subject("宝宝")
let o1 = new Observer("我")
let o2 = new Observer("你")

s.attach(o1)
s.attach(o2)
console.log(s.state);   //开心...
s.setState("不开心...");    //我 状态： 不开心...   你 状态： 不开心...
console.log(s.state);   //不开心...
```



**发布订阅简单实现**  

```javascript
let e = {
    arr:[],
    on(fn){
        this.arr.push(fn)
    },
    emit(){
        this.arr.forEach(fn=>fn())
    }
}
e.on(()=>{
    console.log("哈哈 1");
})
e.on(()=>{
    console.log("哈哈 2");
})

//调一次打印一次
e.emit()    //哈哈 1  哈哈 2  
e.emit()    //哈哈 1  哈哈 2 
```







### JS阻止冒泡和取消默认事件  

防止冒泡和捕获：    

w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true  

stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。    



取消默认事件：   

w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;    



总结使用方法：
当需要停止冒泡行为时，可以使用  

```javascript
function stopBubble(e) { 
//如果提供了事件对象，则这是一个非IE浏览器 
if ( e && e.stopPropagation ) 
    //因此它支持W3C的stopPropagation()方法 
    e.stopPropagation(); 
else 
    //否则，我们需要使用IE的方式来取消事件冒泡 
    window.event.cancelBubble = true; 
}
```



当需要阻止默认行为时，可以使用    

```javascript
//阻止浏览器的默认行为 
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
    return false; 
}
```



### JS是如何运行的？”  

JS代码 ——>解析成AST (期间伴随词法分析、语法分析)——>生成字节码(V8)——>生成机器码(编译器)



### Jquery的优点？  

1.轻量
2.丰富的DOM选择器
3.链式表达式
4.事件、样式、动画支持
5.跨浏览器兼容
6.可扩展性  



### 怎么判断DOM加载完成？  

判断所有DOM加载完成使用onload  

``` javascript
window.onload = function(){
    
}
```
判断某个DOM节点是否加载完毕  

**readyState**  

document.readyState 返回当前文档的状态，属性如下： 
* uninitialized 还未开始加载
* loading 加载中
* interactive 已加载，文档与用户可以开始交互
* complete 加载完成

**DOMContentLoaded**    

当 DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash  



### Jquery(callback)这个callback有什么用？  

当传进去的参数是函数的时候，则在document对象上绑定一个ready事件监听函数，当DOM结构加载完成的时候执行    



```javascript
$(function(){

})
//以上代码和下面的效果是一样的
$(document).ready(function(){
    ...//代码
})
```



### Jquery与Zepto有什么区别？  

Zepto专用于手机端    

jQuery专用于pc端 （但jq又开发出了jquery-mobile,专门用于手机）    

* Zepto特点：Zepto是为现代智能手机浏览器推出的Javascript 框架, 有着和jQuery相似的语法, 但是和jQuery相比下来, 他有很多的优点, 在大小方面 , 压缩后的 zepto.min.js 大小只有21K, 使用服务器端 gzip 压缩后大小只有5~10K, 可以说非常的小, 功能很齐全, 并且多出来了一些触摸屏的事件,它对PC的浏览器就不是那么理想,尤其是在IE上直接过滤不兼容, 所以这个轻量级的js用它来开发手机端和iOS，Android网页都是是不错的选择，极大的减轻了整个app的负载量。  

* jquery特点：jquery主要是用于PC端的页面开发中，jquery是目前最流行的javascript框架，以其兼容全部主流浏览器，插件丰富，代码简洁，最关键的是更新快，其中最好的dom选择器被广泛的使用。而手机wap方面的话，jquery也推出jquery-mobile，也很好用。  

* 相同点：Zepto最初是为移动端开发的库，是jQuery的轻量级替代品，因为它的API和jQuery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，Zepto所提供的工具足以满足开发程序的需要。大多数在jQuery中·常用的API和方法Zepto都有，Zepto中还有一些jQuery中没有的。另外，因为Zepto的API大部分都能和jQuery兼容，所以用起来极其容易，如果熟悉jQuery，就能很容易掌握Zepto。你可用同样的方式重用jQuery中的很多方法，也可以方面地把方法串在一起得到更简洁的代码，甚至不用看它的文档。  

* 不同点：  
  * 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。  
  * Dom操作的区别  
  * 事件触发的区别  
  * 事件委托的区别  
  * width()和height()的区别：Zepto由盒模型(box-sizing)决定，jQuery会忽略盒模型  
  * 等等。。。  



### JS隐式类型转换了解过吗？  

先说出下面代码执行结果(当时面试的时候做错了)

```javascript
if([] == false) {
  console.log(1)
}

if({} == false) {
  console.log(2)
}

if([]) {
  console.log(3)
}

if([1] == [1]) {
  console.log(4)
}
```



**使用==比较中的5条规则**  

* 规则 1：`NaN`和其他任何类型比较永远返回`false`（包括和他自己）  
* 规则 2：`Boolean `和其他任何类型比较，`Boolean `首先被转换为 `Number `类型    
* 规则 3：`String`和`Number`比较，先将`String`转换为`Number`类型。  
* 规则 4：`null == undefined`比较结果是`true`，除此之外，`null`、`undefined`和其他任何结果的比较值都为`false`。  
* 规则 5：`原始类型`和`引用类型`做比较时，引用类型会依照`ToPrimitive`规则转换为原始类型。



**类型转换表**  



![convert-table](D:\桌面\convert-table.png)



参考：[JavaScript 隐式类型转换](https://chinese.freecodecamp.org/news/javascript-implicit-type-conversion/)    



### 说下什么事内存泄漏？  

内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存

并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费

程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存

对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃  



**垃圾回收机制**  

Javascript 具有自动垃圾回收机制（GC：Garbage Collecation），也就是说，执行环境会负责管理代码执行过程中使用的内存

原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存

通常情况下有两种实现方式：

- 标记清除
- 引用计数



>  标记清除

`JavaScript`最常用的垃圾收回机制

当变量进入执行环境是，就标记这个变量为“进入环境“。进入环境的变量所占用的内存就不能释放，当变量离开环境时，则将其标记为“离开环境“

垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉

在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了

随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存

举个例子：

```javascript
var m = 0,n = 19 // 把 m,n,add() 标记为进入环境。
add(m, n) // 把 a, b, c标记为进入环境。
console.log(n) // a,b,c标记为离开环境，等待垃圾回收。
function add(a, b) {
  a++
  var c = a + b
  return c
}
```

> 引用计数

语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放

如果一个值不再需要了，引用数却不为`0`，垃圾回收机制无法释放这块内存，从而导致内存泄漏

```javascript
const arr = [1, 2, 3, 4];
console.log('hello world');
```

面代码中，数组`[1, 2, 3, 4]`是一个值，会占用内存。变量`arr`是仅有的对这个值的引用，因此引用次数为`1`。尽管后面的代码没有用到`arr`，它还是会持续占用内存

如果需要这块内存被垃圾回收机制释放，只需要设置如下：

```javascript
arr = null
```

通过设置`arr`为`null`，就解除了对数组`[1,2,3,4]`的引用，引用次数变为 0，就被垃圾回收了



### 说下函数的防抖和节流以及实现  

**防抖(debounce)：**

在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。

> 典型的案例就是输入框搜索：输入结束后n秒才进行搜索请求，n秒内又输入的内容，则重新计时。  



**节流(throttle)：**

规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效。

> 典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只生效一次。



简单封装：  

```javascript
// 防抖(在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时)
function debounce(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        clearTimeout(timer)
        timer = setTimeout(() => {
            // 改变this指向并传递参数
            fn.apply(this, arguments)
        }, t)
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test(e) {
        // 如果debounce不加参数arguments，这里会打印undefined
        console.log(e)
        // 如果debounce不改变this指向，这里会打印window,而不是DOM节点
        console.log(this)
        container.innerHTML = count++;
    }
    function debounce(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            clearTimeout(timer)
            timer = setTimeout(() => {
                fn.apply(this, arguments)
            }, t)
        }
    }
    container.onmousemove = debounce(test, 1000)
</script>

 */
```



```javascript
// 节流(规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效)
function throttle(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        if (!timer) {
            timer = setTimeout(() => {
                // 为了方便下次执行定时器
                timer = null
                fn.apply(this, arguments)
            }, t)
        }
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test() {
        container.innerHTML = count++;
    }
    function throttle(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            if (!timer) {
                timer = setTimeout(() => {
                    // 为了方便下次执行定时器
                    timer = null
                    fn.apply(this, arguments)
                }, t)
            }
        }
    }
    container.onmousemove = throttle(test, 2000)
</script>

 */
```



参考：[Vue 防抖与节流の使用](https://juejin.cn/post/6844903994121256973)



### 为什么0.1+0.2!==0.3?  

**因为计算机使用的是二进制**  



参考：[详情参考](https://juejin.cn/post/6844903680362151950)



### 说下TS主要是干什么的？  

简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。  



什么是 TypeScript？

- TypeScript 是添加了类型系统的 JavaScript，适用于任何规模的项目。
- TypeScript 是一门静态类型、弱类型的语言。
- TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。
- TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。
- TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。
- TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。
- TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。
- TypeScript 拥有活跃的社区，大多数常用的第三方库都提供了类型声明。
- TypeScript 与标准同步发展，符合最新的 ECMAScript 标准（stage 3）。  



> TS的类型主要有哪些？   

* String  

* Boolean  

* Number   

* Null  

* Undefined  

* Array  

* Tuple(元组)  

* Enum(枚举)  

* Any(任意类型)  

* Void(没有任何类型)    

* Never(不存在的值的类型)  

* 断言  

* ..............

  

### 使用JS实现一个链表  



参考：[用 JavaScript 实现一个链表](https://chinese.freecodecamp.org/news/implementing-a-linked-list-in-javascript/)  



### 怎么遍历一个链表？  



参考：[JS中的链表操作](https://www.cnblogs.com/WindrunnerMax/p/12881550.html)  





## Vue  



### 说下MVC、MVP、MVVM有什么区别？  

**MVC**  

实线表示调用，虚线表示通知   

![MMVC1](D:\桌面\MMVC1.png)

Controller 是 MVC 中的 C，指控制层，在 Controller 层会接收用户所有的操作，并根据写好的代码进行相应的操作——触发 Model 层，或者触发 View 层，抑或是两者都触发。  
需要注意：Controller 层触发 View 层时，并不会更新 View 层中的数据，View 层中的数据是通过监听 Model 层数据变化而自动更新的，与 Controller 层无关。    

![MMVC2](D:\桌面\MMVC2.png)



**MVP**  

![MMVP1](D:\桌面\MMVP1.png)

在 MVC 框架中，View 层可以通过访问 Model 层来更新，但在 MVP 框架中，View 层不能再直接访问 Model 层，必须通过 Presenter 层提供的接口，然后 Presenter 层再去访问 Model 层。

这看起来有点多此一举，但用处着实不小，主要有两点：  
* 首先是因为 Model 层和 View 层都必须通过 Presenter 层来传递信息，所以完全分离了 View 层和 Model 层，也就是说，View 层与 Model 层一点关系也没有，双方是不知道彼此存在的，在它们眼里，只有 Presenter 层。  
* 其次，因为 View 层与 Model 层没有关系，所以 View 层可以抽离出来做成组件，在复用性上比 MVC 模型好很多。    

![MMVP2](D:\桌面\MMVP2.png)

View 层与 Model 层确实互不干涉，View 层也自由了很多。但还是有问题，因为 View 层和 Model 层都需经过 Presenter 层，致使 Presenter 层比较复杂，维护起来会有一定的问题。  
而且因为没有绑定数据，所有数据都需要 Presenter 层进行“手动同步”，代码量比较大，虽然比 MVC 模型好很多，但也是有比较多的冗余部分。    



**MVVM**  

![MMVVM1](D:\桌面\MMVVM1.png)

可能感觉 MVVM 的框架图与 MVP 的框架图相似，确实如此，两者都是从 View 层开始触发用户的操作，之后经过第三层，最后到达 Model 层。但是关键问题是这第三层的内容， ViewModel 层双向绑定了 View 层和 Model 层，因此，随着 View 层的数据变化，系统会自动修改 Model 层的数据，反之同理。而 Presenter 层是采用手动写方法来调用或者修改 View 层和 Model 层，两者孰优孰劣不言而喻。    

![MMVVM2](D:\桌面\MMVVM2.png)





### Vue是什么？  

Vue.js（是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。    

Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。    

另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。    

Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。   



### 说下MVVM模式的实现原理  

即Model-View-ViewModel。  

Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化  

ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。    

DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。      



参考：[Vue MVVM理解及原理实现](https://juejin.cn/post/6844903929298288647)



### 说下Vue的双向绑定数据的原理  

Vue 实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。  



### 简要说明Vue 2.x的全链路运作机制？  

 

1. 初始化以及挂载init, mount    
2. 再进行模板编译compile,将template编译为渲染函数render function    
3. 执行render function生成Virtual DOM, render function => VNode tree     
4. 再进行响应式依赖收集, render function=> getter,setter => Watcher.update => patch。以及使用队列进行异步更新的策略。    
5. 最后通过diff算法后进行patch更新视图



### 说下Vue的优缺点？  

- 优点

  - 易用

  ```
  已经会了 HTML、CSS、JavaScript？
  ```

  - 灵活

  ```
  1.拥有不断繁荣的生态系统(vue route, vuex,vue服务端渲染)
  2.可以使用一个库或者一个框架进行开发
  ```

  - 高效

  ```
  运行大小20kB,
  ```

  ```
  超快虚拟 DOM
  浏览器解析页面步骤                         :  
  	1.解析HTML,生成HTML树,
  	2.解析css,生成样式树,
  	3.HTML和css结合,
  	4.生成坐标点
  	5.开始渲染页面
  	
  举个栗子:
  	如果有一个元素需要修改,浏览器执行一次以上5个步骤,如果有10个元素需要修改,此时浏览器需要执行以上10次5个步骤.
  	
  虚拟dom(virtual dom)
  虚拟dom存在于内存当中,可以把它理解为一个Object(对象)
  如果有需要修改的元素,把它放在虚拟DOM中进行修改,修改完成之后,虚拟DOM会自动的跟真实的DOM进行对比,将产生差异的部分,进行页面的渲染.
  
  
  如果渲染页面时,采用了vue,
  如果需要修改10个元素,统一放在虚拟DOM中进行执行修改,修改完成之后,将虚拟DOM和真实DOM进行对比,产生差异的部分,统一再次进行页面的渲染.这样的执行只需执行以上1次五个步骤.
  
  优势:
  	1.高效.
  	2.浏览器只需执行一次修改.
  	3.js解析js比浏览器解析js快的多.
  ```

  ```
  最省心的优化
  1.transform:对元素进行2D或者3D转换,在写样式时,需要在前边增加各种前缀:-webkit -moz -o -ms,如果使用了vue,既不需要在前边那些前缀了/.vue中做了集成的优化.
  2.之前在js中操作元素:  先获取 加事件 在操作
   如果你是用vue,直接操作数据即可.
  ```

  - 渐进式javascript框架  
  - SPA(single page application)单页面应用

  ```
  普通页面之间跳转: 就是真实的页面之间进行跳转(N.html)
  单页面之间跳转:  始终只有一个页面(index.html)
  
  优点:
  	1.用户体验好.
  	2.适合前后端分离
  缺点:
  	1.不利于SEO优化.
  	2.首屏加载速度慢.加载时,将所有的css,js文件进行加载.
  ```

- 缺点

```
1.不利于SEO优化.
2.首屏加载速度慢.加载时,将所有的css,js文件进行加载.
3.不支持IE8以下
```



### 单页面应用和多页面应用区别及优缺点  

* 单页面应用（SPA），通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源，多应用于pc端。  

* 多页面（MPA），就是指一个应用中有多个页面，页面跳转时是整页刷新。  

单页面的优点：   

* 用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小    
* 前后端分离    
* 页面效果会比较炫酷（比如切换页面内容时的专场动画）   

单页面缺点：    

* 初次加载时耗时多    
* 页面复杂度提高很多    
* 导航不可用，如果一定要导航需要自行实现前进、后退。



### Vue的两个核心是什么？  

* 数据驱动  
* 组件系统  



### 能说下Vue的响应式系统吗？  

* 任何一个 Vue Component 都有一个与之对应的 Watcher 实例  
* Vue 的 data 上的属性会被添加 getter 和 setter 属性  
* 当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)  
* data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新    



### 说下v-show与v-if的区别？  

都是条件渲染指令  

与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中，v-show指令只是设置了元素CSS的style值  ；  

而只有当v-if的值为true，元素才会存在于HTML代码中。



### 为什么避免 v-if 和 v-for 用在一起？   

当Vue 处理指令时，v-for 比 v-if 具有更高的优先级，这意味着v-if将分别重复运行于每个v-for循环中。  

通过v-if 移动到容器元素，不会再重复遍历列表中的每个值。取而代之的是，我们只检查它一次，且不会在 v-if 为否的时候运算 v-for。  



> Vue3.x中调整了这两个指令的优先级，不会出现这样的问题



### 说下Vue的生命周期以及应用？  

Vue的生命周期主要分为beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed   



**简单应用：**

**beforeCreate** : 可以在这加个loading事件，在加载实例时触发

**created** : 初始化完成时的事件写在这里，如在这结束loading事件，异步请求也适宜在这里调用

**mounted** : 挂载元素，获取到DOM节点

**updated** : 如果对数据统一处理，在这里写上相应函数

**beforeDestroy** : 可以做一个确认停止事件的确认框



**注：mounted中调用方法改变data数据可能引起二次渲染**



参考：[Vue 生命周期与钩子函数](https://juejin.im/post/5d4591315188257b6546f04e)  



### 你通常在哪个生命周期内调用异步请求？  

可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。  

但是本人推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：

* 能更快获取到服务端数据，减少页面 loading 时间；  
* ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；  



### 说下keep-alive指令  

`keep-alive`是`vue`中的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染`DOM`

`keep-alive` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们

`keep-alive`可以设置以下`props`属性：

- `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存
- `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存
- `max` - 数字。最多可以缓存多少组件实例



关于`keep-alive`的基本用法：  

```vue
<keep-alive>
  <component :is="view"></component>
</keep-alive>
```

使用`includes`和`exclude`：  

```vue
<keep-alive include="a,b">
  <component :is="view"></component>
</keep-alive>

<!-- 正则表达式 (使用 `v-bind`) -->
<keep-alive :include="/a|b/">
  <component :is="view"></component>
</keep-alive>

<!-- 数组 (使用 `v-bind`) -->
<keep-alive :include="['a', 'b']">
  <component :is="view"></component>
</keep-alive>
```

匹配首先检查组件自身的 `name` 选项，如果 `name` 选项不可用，则匹配它的局部注册名称 (父组件 `components` 选项的键值)，匿名组件不能被匹配

设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（`activated`与`deactivated`）：

- 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created`> `mounted` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`
- 再次进入组件时：`beforeRouteEnter` >`activated` > ... ... > `beforeRouteLeave` > `deactivated`



### 说下Vue的导航守卫  

全局的  
* router.beforeEach  
* router.beforeResolve  
* router.afterEach  

单个路由独享的  
* beforeEnter  

组件级的  
* beforeRouteEnter  
* beforeRouteUpdate  
* beforeRouteLeave    

参考：[Vue 导航守卫(路由的生命周期)](https://juejin.im/post/5d529884f265da03a1484e56)    



### 说下route和router的区别是什么？



route是“路由信息对象”，包括path,params,hash,query,fullPath,matched,name等路由信息参数。  

router是“路由实例对象”，包括了路由的跳转方法(push、replace)，钩子函数等。  



### 说下Vue中的路由嵌套

路由嵌套会将其他组件渲染到该组件内，而不是进行整个页面跳转。    

router-view本身就是将组件渲染到该位置。



### 如何让CSS只在当前组件中起作用？  

在当前组件的`<style>`标签中添加`scoped`属性  



之后在项目编译后每个组件会生成独有的hash值用来区分。(通常在vue项目编译后审查的时候你都会看到例如`data-hdsiuhbjc`的东西，就是通过这个来区分的)  



### Vue中怎么重置data？  

Vue实例中的`$options`保留了初始化组件中的所有状态 。  



### 说下Vue中常用的指令以及修饰符  

**常用的指令：**  

* v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。

* v-show：根据表达式之真假值，切换元素的 display CSS 属性。

* v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key值 使用。

* v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。

* v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。

* v-model：实现表单输入和应用状态之间的双向绑定

* v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。

* v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。





**v-model指令常用修饰符：**

* .lazy - 取代 input 监听 change 事件

* .number - 输入字符串转为数字

* .trim - 输入首尾空格过滤



**v-on指令常用修饰符：**  

* .stop - 调用 event.stopPropagation()，禁止事件冒泡。

* .prevent - 调用 event.preventDefault()，阻止事件默认行为。

* .capture - 添加事件侦听器时使用 capture 模式。

* .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。

* .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。

* .native - 监听组件根元素的原生事件。

* .once - 只触发一次回调。

* .left - (2.2.0) 只当点击鼠标左键时触发。

* .right - (2.2.0) 只当点击鼠标右键时触发。

* .middle - (2.2.0) 只当点击鼠标中键时触发。

* .passive - (2.3.0) 以 { passive: true } 模式添加侦听器。



**v-bind指令常用修饰符：**

* .prop - 被用于绑定 DOM 属性 (property)

* .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)

* .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器



### 你自定义过指令吗？  

先了解下Vue.use做了哪些事？  

* 检查插件是否安装，如果安装了就不再安装  
* 如果没有安装，那么调用插件的install方法，并传入Vue实例      



Vue 自定义指令有全局注册和局部注册两种方式。    

注册全局指令的方式，通过 Vue.directive( id, [definition] ) 方式注册全局指令。然后在入口文件中进行 Vue.use() 调用。   

指令定义函数提供了几个钩子函数（可选）：
* bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。
* inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。
* update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。
* componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。
* unbind: 只调用一次， 指令与元素解绑时调用。  



![VueDefinition](D:\桌面\VueDefinition.png)





### Vue中key值的作用   

当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。  

**key 的作用主要是为了高效的更新虚拟DOM**  



> 追问：为什么key必须要唯一，且不要用index作为key？  

key为什么要唯一？  

答：key的作用主要是为了高效的更新虚拟dom，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少dom操作量，提高性能。



为什么不要用index作为key？  

* 如果用index作为key，那么key设置的就没什么意义，并不会使patch过程变得高效  
* 会出现意想不到的bug  
* 列表的顺序难以保证  



给个例子：  

```vue
<template>
    <div id="app">
        使用唯一标识id作为key值
        <div v-for="item in list" :key="item.id">
            {{item.name}}
            <input type="text">
        </div>
        <hr>
        使用index作为key值
        <div v-for="(item, index) in list" :key="index">
            {{item.name}}
            <input type="text">
        </div>
        <hr>
        <button @click="add">往列表头部添加一条数据</button>
    </div>
</template>

<script>
export default {
    name: 'App',
    data() {
        return {
            list: [
                {
                    id: 1,
                    name: 'fan',
                },
                {
                    id: 2,
                    name: 'jun',
                },
                {
                    id: 3,
                    name: 'yang',
                },
            ]
        }
    },
    methods: {
        add() {
            this.list = [{id: 4, name: 'hello'}, ...this.list]
        }
    },
}
</script>
```

在输入框里输入值，然后往列表头部添加数据的时候（触发add方法），会发生意想不到的bug，看到没，如果用index作为key，输入框里的数据错乱了  

![key](D:\桌面\key.gif)

### 谈谈你对虚拟DOM的理解？   

首先,我们都知道在前端性能优化的一个秘诀就是尽可能少地操作DOM,不仅仅是DOM相对较慢,更因为频繁变动DOM会造成浏览器的回流或者重绘,这些都是性能的杀手,因此我们需要这一层抽象,在patch过程中尽可能地一次性将差异更新到DOM中,这样保证了DOM不会出现性能很差的情况.  

其次,现代前端框架的一个基本要求就是无须手动操作DOM,一方面是因为手动操作DOM无法保证程序性能,多人协作的项目中如果review不严格,可能会有开发者写出性能较低的代码,另一方面更重要的是省略手动DOM操作可以大大提高开发效率。  



### 说下虚拟 DOM 的优缺点？  

优点：  
* 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；  
* 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；  
* 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。  

缺点：  
* 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。     



### 说下虚拟DOM的实现原理  

虚拟 DOM 的实现原理主要包括以下 3 部分：  
* 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；  
* diff 算法 — 比较两棵虚拟 DOM 树的差异；  
* patch 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。   



> 说到这里有可能会问你diff和patch算法的实现原理，这个自己下去看看源码吧



### 组件中写 name 选项有什么作用？  

* 项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤  
* DOM 做递归组件时需要调用自身 name  
* vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的    



### nextTick是做什么的(以及原理)？  

Vue 是异步修改 DOM 的并且不鼓励开发者直接接触 DOM，但有时候业务需要必须对数据更改--刷新后的 DOM 做相应的处理，这时候就可以使用 Vue.nextTick(callback)这个 api 。  



`$nextTick`是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用`$nextTick`，则可以在回调中获取更新后的 DOM 



原理参考：[理解Vue中的 nextTick](https://juejin.cn/post/6844903962039025678)



### Vue组件中的data为什么必须是函数？  

因为JS本身的特性带来的  

因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响。  

如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响。而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。



### watch和computed有什么区别以及应用场景？  



参考：[Vue中watch、computed与methods的联系和区别](https://juejin.cn/post/6844904086349807624)    



### Vue的父组件和子组件生命周期钩子函数执行顺序？  

* 加载渲染过程    （父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted）  
* 子组件更新过程  （父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated）  
* 父组件更新过程  （父 beforeUpdate -> 父 updated）  
* 销毁过程  （父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed  ）  



### Vue组件间通信有哪几种方式？  

* props  
* $emit  
* $attr  
* $listener  
* provide  inject  (隔代通信)  
* $parent  $children  
* vuex    



详情参考：[Vue组件之间的数据传递(通信、交互)详解](https://juejin.cn/post/6844903911564787720)



### Vuex相关问题  

>  vuex是什么?  

vue框架中状态管理。  

>  vuex有哪几种属性?  

有五种，分别是 State、 Getters、Mutations 、Actions、 Module  

vuex的State特性  

* Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于一般Vue对象里面的data  

* state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新  

* 它通过mapState把全局的 state 和 getters 映射到当前组件的 computed 计算属性中  

vuex的Getters特性  

* getters 可以对State进行计算操作，它就是Store的计算属性  

* 虽然在组件内也可以做计算属性，但是getters 可以在多组件之间复用  

* 如果一个状态只在一个组件内使用，是可以不用getters  

vuex的Mutations特性  

* Actions 类似于 mutations，不同在于：Actions 提交的是 mutations，而不是直接变更状态;Actions 可以包含任意异步操作。  

>  不用Vuex会带来什么问题?  

* 可维护性会下降，想修改数据要维护三个地方;   

* 可读性会下降，因为一个组件里的数据，根本就看不出来是从哪来的;  

* 增加耦合，大量的上传派发，会让耦合性大大增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背；  



同步异步区别：    

1、流程顺序  “相应视图—>修改State”拆分成两部分，视图触发Action，Action再触发Mutation。      

2、角色定位  基于流程顺序，二者扮演不同的角色。    

* Mutation：专注于修改State，理论上是修改State的唯一途径。    

* Action：业务代码、异步请求。    

3、限制    

角色不同，二者有不同的限制。    

* Mutation：必须同步执行。    

* Action：可以异步，但不能直接操作State。   

Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。    



每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。**如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难**。



### Vuex实现原理(和Redux对比)  

Redux 的核心概念

- action （同步action ，或借助 中间件 实现异步操作，action 不会改变 store，只是描述了怎么改变store）| mutation（用于同步操作） 、action（可用于异步操作，提交 mutation）
- reducer（纯函数，根据 action 和旧的 store 计算出新的 store
- store（单一数据源）

Vuex 的核心概念

- mutation（用于同步操作） 、action（可用于异步操作，提交 mutation）
- mutation里面直接修改 state
- state（单一数据源）  



其他：

i） Redux 提供了 `store.getState()` 这个 API 获取 store 树，还有 `store.subscribe(listener)` 订阅 store 的变化，当 store 改变时会调用监听器；Vuex 有一个 `getter` 的概念用于根据 state 派生出一些数据，像 Vue 的计算属性一样，当 state 改变时会重新计算出一个结果出来，提供给需要的组件。

ii） 对于大型项目，当应用状态数据过于复杂，可以划分状态，这样便于管理数据流向。Redux 可以通过 `combineReducers（）`结合各个组件的 reducer，各个组件可以单独管理自己的状态，最后合并为一个 reducer 用于生成一个 store；Vuex 这方面用 `Module` 这个概念划分 store，与 Redux 一样，可以多层嵌套子状态。

iii） 将状态数据绑定到视图：Redux 将状态映射到视图可以通过 React-redux 映射到 React 组件， 当然也可以直接使用 Redux 自己提供的 `store.subscribe()` 订阅 store 的改变，从而更新视图，因此 Redux 不仅仅可以用于 React，也可以用于其他框架如 Vue；而 Vuex 只能用于 Vue，它提供了 `mapState`、`mapAction`、`mapMutations` 等API 将 store 映射到 Vuex 各个组件，这个参考了 React-redux 的 `mapStateToProps`。  



**使用原则**  

Redux 的三大原则：

```text
（1）单一数据源（一个Redux应用只有一个store），也是单向的数据流；
（2）state只读（唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。）；
（3）使用纯函数（reducer）来修改state。
```

Vuex 的三大原则：

```text
a. 应用层级的状态应该集中到单个 store 对象中。
b. 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。
c. 异步逻辑都应该封装到 action 里面。
```



**处理异步操作**  

Redux 得益于 中间件机制，利用 redux-thunk `（redux-thunk 可以 dispatch 函数，这个函数用于生成 action，所以在这个函数里面我们可以进行异步操作，等异步的结果出来后再放在 action 里面将这个 action 用 dispatch 分发出去, 而这个函数被叫做 “action creator” ）`，可以将异步逻辑放在 action creator 里面，通过 action creator 做一个控制反转， 给 action creator 传入 dispatch 作为参数，于是就可以 dispatch action，`（原本是通过 dispatch 来分发 action ,现在是异步 action 即 action creator 掌握了控制权调用 dispatch，所以叫控制反转`），Redux 并没有创造单独的概念出来专门用于异步逻辑，它是利用了 Redux 自己实现的中间件机制，中间件从 dispatch 一个异步 action 到 action 到达 reducer 之间处理 action，在这期间通过异步操作得到的结果可以放到 action 里面再通过 dispatch 分发到 reducer，以前 dispatch 一个 action 之后，这个 action 回立即到达 reducer ，所以是同步 action，现在在 action creator 里面，我们通过控制反转，可以等待异步操作结果再生成 action 分发，所以叫做异步 action  



而 Vuex 是用 mutation 来对应 Redux 的 action，另外 Vuex 又创造了一个 action 来提交 mutation 并通过异步提交 mutation 来实现异步操作结果能够到达 state  



### Vue中$attrs使用时需要注意的点  

详细：
包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind="$attrs" 传入内部组件。  

使用介绍
从官方介绍我们可以得出 `$attrs` 应用于父子传值场景下，子组件通过 `$attrs` 可以访问父组件传过来的所有属性，但需要注意的是**如果父组件所传的属性中有在子组件 `props` 中有过声明，那么该属性不会出现在 `$attrs` 对象中**。  



### Vue中为什么不能用a标签？  

因为用Vue做的都是单页应用，就相当于只有一个主的index.html页面，所以写的a标签是不起作用的，必须使用vue-router来进行管理。  



在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。**路由模块的本质就是建立起url和组件之间的映射关系**。 



### 说下vue-router吧  



> 怎么定义vue-router的动态路由以及如何获取传过来的动态参数？  

在router目录下的index.js文件中，对path属性加上/:id。
使用route对象的`params.id`获取数据  



参考：[Vue 路由传值(传参)详解](https://juejin.cn/post/6844903938752282631)  



> active-class是哪个组件的属性？  

vue-router模块的router-link组件，主要用来控制点击样式问题。    



> hash与history的区别？（重点）

vue-router 有 3 种路由模式：hash、history、abstract   
* hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；  
* history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；  
* abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.  

> hash模式    
>
> 我们先来认识下这位朋友 #，这个 # 就是hash符号，中文名哈希符或锚点，当然这在我们前端领域姑且这么称呼。
> 然后哈希符后面的值，我们称之为哈希值。OK，接下来我们继续分析他的原理。路由的哈希模式其实是利用了window可以监听`onhashchange`事件，也就是说你的url中的哈希值（#后面的值）如果有变化，前端是可以做到监听并做一些响应（搞点事情），这么一来，即使前端并没有发起http请求他也能够找到对应页面的代码块进行按需加载。

> history模式    
>
> 我们先介绍一下H5新推出的两个神器：pushState与replaceState
> 具体自行百度，简而言之，这两个神器的作用就是可以将url替换并且不刷新页面，好比挂羊头卖狗肉，http并没有去请求服务器该路径下的资源，一旦刷新就会暴露这个实际不存在的“羊头”，显示404。
> 那么如何去解决history模式下刷新报404的弊端呢，这就需要服务器端做点手脚，将不存在的路径请求重定向到入口文件（index.html），前后端联手，齐心协力做好“挂羊头卖狗肉”的完美特效。
> 至此，我们的前端路由在实现与展示效果上又更进了一步！
> 总之，pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。

在history模式中，浏览器在刷新的时候，会按照路径发送真实的资源请求，如果这个路径是前端通过 history API 设置的 URL，那么在服务端往往不存在这个资源，于是就返回 404了    

因此在线上部署基于 history API的单页面应用的时候，一定要后端配合支持才行，否则会出现大量的 404。
以最常用的 Nginx 为例，只需要在配置的 location / 中增加下面一行即可：  

``` 
try_files $uri /index.html
```



参考：[Vue的mode中 hash 与 history 的区别](https://juejin.cn/post/6844903902928879623)  

深入理解：[理解vue-router中(router-link router-view $router $route)实现原理](https://juejin.cn/post/6844903942128664584)



### slot知道吗？ 

slot就是Vue中的插槽，相当于先挖个坑，如果有组件的话，可以渲染到该位置  

插槽分类：  

* 内容插槽  
* 默认插槽  
* 具名插槽  
* 作用域插槽  
* 动态插槽



参考：[Vue 插槽(slot)使用(通俗易懂)](https://juejin.cn/post/6844903920037281805)



### Vue中如何动态绑定Class和Style？  



参考：[Vue Class与Style绑定](https://juejin.im/post/5da1990b51882518fa5a3877)  



### 怎样理解Vue的单向数据流？

所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。  

额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。    



### 直接给一个数组项赋值，Vue能检测到变化吗？  

由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：  
* 当你利用索引直接设置一个数组项时，例如：vm.items\[indexOfItem] = newValue  
* 当你修改数组的长度时，例如：vm.items.length = newLength    



> 追问：那么解决方法有哪些？  

* 使用Proxy(Vue3.x最重要的改动)  
* 使用`$set`  
* 改变数组的引用地址，相当于新数组    



### Vue.delete与delete的区别？  

delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。    

Vue.delete 直接删除了数组 改变了数组的键值。    



### Vue中data/computed相关问题  

> data中有属性A、B、C，计算属性D依赖A和B，那么在D中可以直接修改C的值吗？    
>
> 答：可以。     
>
> 如果我又在D中修改A，会出现问题吗？   
>
> 答：不会出现问题，会拿到新修改的值计算

> 计算属性A和B，如果A中用了B，B中用了A，会出现问题吗？如果出现问题，会造成什么影响？    
>
> 答：直接报错：超过最大调用堆栈大小

> 如果在data中定义了属性A，在计算属性也定义了A，会出现问题吗？     
>
> 答：会报警告，最后用的是data中的值，不用计算属性的值  

如果在data中这样定义，A的最终值是多少？  答：1

``` 
data() {
	this.A = 5
	return {
		A: 1,
		B: 2,
	}
},
```



### axios的优点有哪些？  

1.简单易用    

2.兼容性好    

3.通用性好    

4.稳定    

5.提供了一些并发请求    

6.支持拦截请求和响应    

7.安全，支持防御    

8.支持Promise    





### 如何取消Ajax请求？  

原生 Ajax 取消方式    

对于原生XHR对象来说，取消的ajax的关键是调用XHR对象的.abort()方法，请求被中断之后会触发 onabort 事件不会触发 error 事件  

``` javascript
let ajax = new XMLHttpRequest();
ajax.open("POST", "/api/sys/listTmallShop");
ajax.send(null);
ajax.onreadystatechange = function () {
    if (ajax.readyState === 4) {
        console.log(ajax.response);
    }
};
ajax.onabort = function () {
    console.log("请求被中断");
};
// 立即取消请求
ajax.abort();
```
jquery 取消方式    

由于 jquery 的 ajax 函数会返回一个原生的 xhr 对象所以可以通过这个对象调用原生的 abort 方法取消请求，取消之后会触发 error 事件  

``` javascript
var jp = $.ajax({
    type: "post",
    url: "/api/sys/listTmallShop",
    data: {
        platform: "TMALL",
        page: 1
    },
    success: function (data) {
        console.log("成功了");
        console.log(data);
    },
    error: function (err) {
        console.log("取消了");
        console.log(err);
    }
});
jp.abort();
```
axios 的取消方式    

axios的取消需要使用 CancelToken 获取取消令牌，并且用令牌标识单个请求，之后调用令牌的 cancel 即可取消  

``` javascript
const CancelToken = axios.CancelToken;
const source = CancelToken.source();

axios.post("/api/sys/listTmallShop", null, {
    cancelToken: source.token
}).catch(function (thrown) {
    if (axios.isCancel(thrown)) {
        console.log("取消了", thrown.message);
    } else {
        console.log("出错了");
    }
});

source.cancel("取消原因：老子愿意"); 
```
如果多个请求可以多次执行 CancelToken.source() 拿到多个 token对象   

除了以上的方式还有一种方式可以取消请求  

``` javascript
const CancelToken = axios.CancelToken;
let cancel;

axios.get('/user/12345', {
  cancelToken: new CancelToken(function executor(c) {
    // An executor function receives a cancel function as a parameter
    cancel = c;
  })
});

// cancel the request
cancel();
```



### 常用哪些方法解决跨域？  

* 前端配置vue.config.js（使用proxy）     
* 前端使用jsonp（只能处理get请求）
* 后端配置cors（配置各种头）  
* 后端配置nginx  



> jsonp的原理？  

使用了src标签没有跨域限制来实现的  

具体步骤：    

1. 创建一个script标签  
2. script的src属性设置接口地址  
3. 接口参数，必须要带一个自定义函数名，要不然后台无法返回数据   
4. 通过定义函数名去接受返回的数据  

```javascript
// 手写JSONP  
function jsonp(url, params = {}, callback) {
    // 处理json对象，拼接url
    params.callback = callback
    const paramsArr = []
    for (const key in params) {
        paramsArr.push(`${key}=${params[key]}`)
    }
    let script = document.createElement('script')
    script.src = `${url}?${paramsArr.join('&')}`
    document.body.appendChild(script)
    return new Promise((reslove, reject) => {
        window[callback] = res => {
            try {
                reslove(res)
            } catch(e) {
                reject(e)
            } finally {
                // 移除script
                script.parentNode.removeChild(script)
            }
        }
    })
}
```





### 说下vue.cli项目中src目录每个文件夹和文件的用法  

assets文件夹是放静态资源；    

components是放组件；    

router是定义路由相关的配置;    

view视图；    

app.vue是一个应用主组件；    

main.js是入口文件；     



### Vue打包后生成的.map文件有什么作用？

.map文件的生成与否可以在vue.config.js中配置，如下：  
```javascript
module.exports = {
    productionSourceMap: true,
}
```
当设置为true时，则打包后会生成.map文件，则前端服务把静态资源跑起来的时候，如果有报错信息，错误提示里可以直接定位到某某vue文件哪一行那一列出错了，可以直接点击查看。  
如果设置为false，则打包后不会生成.map文件，则前端服务把静态资源跑起来后，如果有报错信息，则错误提示里直接压缩后的.js文件，无法定位到是哪个vue文件，哪一行出错了。   



### Vue3.0有没有了解过？    

**性能提升**  

- 打包大小减少41%
- 初次渲染快55%, 更新渲染快133%
- 内存减少54%
- **使用Proxy代替defineProperty实现数据响应式**
- **重写虚拟DOM的实现和Tree-Shaking**  



**新增特性**  

- **Composition (组合) API**
- setup
  - ref 和 reactive
  - computed 和 watch
  - 新的生命周期函数
  - provide与inject
  - ...
- 新组件
  - Fragment - 文档碎片
  - Teleport - 瞬移组件的位置
  - Suspense - 异步加载组件的loading界面
- 其它API更新
  - 全局API的修改
  - 将原来的全局API转移到应用对象
  - 模板语法变化

----------

关于Vue 3.0，大致说了三个点：  

* 第一个是关于提出的新API setup()函数，setup创建组件实例时，在初始组件解析后立即调用。在生命周期方面，它在beforeCreate之前被调用（2.x）
* 第二个说了对于Typescript的支持  
* 第三个详细说了下关于Proxy代替带来的性能上的提升，因为传统的原型链拦截的方法，无法检测对象及数组的一些更新操作，但使用Proxy又带来了浏览器兼容问题。  



一些小东西：  

* 调整v-if与v-for的优先级  
* 可以没有根标签  
* 默认导出一个组件  
* ...................  



### Proxy与Object.defineProperty优劣对比  

Proxy 的优势如下:  
* Proxy 可以直接监听对象而非属性；  
* Proxy 可以直接监听数组的变化；  
* Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是Object.defineProperty 不具备的；  
* Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；  
* Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；   



Object.defineProperty 的优势如下:  

* 兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。





### Vue项目中怎么做性能优化    

列举一些，自己看着说，语言丰富以下即可  

* data优化（对象层级不要过深，不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据））  
* 巧妙利用指令v-if(show)，使用v-for要绑定key   
* 路由懒加载  
* 动态导入组件  
* 图片懒加载  
* 第三方模块按需导入  
* 骨架屏  
* PWA缓存  
* 预渲染  
* 缓存和压缩  
* HTTP优化  
* computed 和 watch 区分使用场景
* 大数据列表和表格性能优化-虚拟列表/虚拟表格
* 防止内部泄漏，组件销毁后把全局变量和事件销毁
* 适当采用 keep-alive 缓存组件
* 防抖、节流运用
* 服务端渲染 SSR or 预渲染   
* 文件压缩，减小资源大小  
* 小图片转base64，减少请求  
* 雪碧图，减少请求  
* 渲染优化（重绘、回流）  
* 减少cookie的使用，减少请求携带大小    



这位大佬写的非常好，可以参考一下：[写给中高级前端关于性能优化的9大策略和6大指标](https://juejin.cn/post/6981673766178783262)  



## React  



## 后端&运维  



## 算法题&手写原理  



## 项目相关  

### 适配方案  

通常使用REM+Flex布局实现适配    

```javascript
<script>
	;(function () {
		// 设计稿宽度 px
		var designWidth = 375
		// rem 基准字号 px
		var baseFontSize = 100
		// 最大适配宽度 px
		var maxAdaptWidth = 1024

		var adaptDevice = function () {
			var deviceWidth = document.documentElement.clientWidth
			deviceWidth = deviceWidth > maxAdaptWidth ? maxAdaptWidth : deviceWidth
			var scale = deviceWidth / designWidth
			var adaptRootFontSize = baseFontSize * scale
			document.querySelector('html').style.fontSize = adaptRootFontSize + 'px'
		}

		var timer = 0
		window.addEventListener('resize', function () {
			if (timer) {
				clearTimeout(timer)
				timer = 0
			}

			timer = setTimeout(function () {
				adaptDevice()
			}, 0)
		})

		setTimeout(adaptDevice, 0)
	}())
</script>
```





### 记录  

项目权限问题  

封装过axios吗？  

断点续传  

首页白屏怎么解决  

怎么管理状态  









# 非技术相关   

参考我的文章：[【非技术性问题】](https://juejin.cn/post/6844904008335753224)  

