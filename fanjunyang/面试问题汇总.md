[toc]  



本人历经一个月的鏖战，终于斩获了自己心仪的offer，以下是在面试过程中获取的一些经验，希望可以帮到大家，也省去大家搜索资料的过程，其实面试大多时候都是背八股文，没办法，我们只好顺应，如果答案之中有链接的话，最好点进去大致看下。  

> 注意：面试找工作是一个**双向奔赴**的过程，在面试过程中要做到**不卑不亢**  

# 个人介绍  

这个环节非常重要，可以让面试官了解一下你的大致情况，时间控制在1~3min即可，具体可以从以下几个方面介绍：  

* 个人的基本情况（姓名、毕业院校、专业等）
* 工作相关（日常主要负责哪些项目开发、主要使用到哪些技术栈，参与过哪些项目的研发等）  
* 生活相关（性格、兴趣爱好、是否容易相处、学习能力、适应能力等）  
* 其他（可以介绍下自己感兴趣的一些东西，比如：技术，封装过一些类库等）    

示例(可以自己临场发挥)：   

我叫xxx，毕业于xx大学中的xx专业，目前有n年的工作经验。在工作中主要负责xxx系统的日常开发和维护，除了主要负责xxx系统外，也参与过yyy系统的开发，包括也会封装一些常用的组件和方法等，也会做一些后端中间层，包括API接口的开发工作，其中主要使用到的技术找是：例如：Vue、React、Jquery、Zepto、uniApp、Node等等（自由发挥，丰富下自己的语句），在生活中，我是一个乐于助人、幽默开朗、诚实守信、乐观向上、严于律己的一个人，跟同事相处的非常融洽和谐(自己根据[搜索](http://www.360doc.com/content/16/0623/16/34147982_570159625.shtml)内容整理下)，除了日常工作之外，我会看一些书籍(非技术性相关的也可以)来丰富自己的知识、扩展自己的视野，并且经常记一些笔记和写一些技术博客，包括也会自己搭一些框架，做一些自己的项目等。。。这是我个人的一些基本情况，谢谢。

# 技术相关  

俗话说：是骡子是马拉出来溜溜，想要获取一份好工作，只会吹是不行的，必须要有**真才实学**，技术牛皮的话，你想咋样咋样。    

虽然说在工作中主要负责的是前端这一块，但是有些后端的知识也必须了解，这样才能在工作中更加的得心应手，包括前端面试的时候不一定只问前端相关的知识。

以下罗列了一些常见的问题，包括但不限于：    

* HTTP(网络)

* HTML(5) & CSS(3)  
* JS(ES5、ES6、ES7、ES8、ES9、ES10、ES11、ES12等)  
* Vue  
* React  
* 后端(Node、Mysql、Redis等)  
* 运维  
* 常见的算法      
* 项目相关    

> 如果标题上加 ”，表示了解即可，不必强记

## HTTP(网络)   

### 简单说下网络模型“  

参考：[网络七层模型（四层模型）及其区别](https://juejin.cn/post/6844903939918266382)    



### 简单介绍下TCP连接 

TCP的三次握手和四次挥手，为什么一个要三次，一个要四次？  



参考：[TCP 三次握手 与 四次挥手](https://juejin.cn/post/6844903888529653767)  



### 说下TCP与UDP有什么区别？  

![MTCPAndUDP](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MTCPAndUDP.png)



### 从输入一个网址到看到一张网页，经历了什么？  

参考：[从输入一个网址到浏览器显示页面的全过程详细分析](https://juejin.cn/post/6844903888483516430)  



其中的某些过程说的越详细越好，比如拿到数据浏览器是如何渲染到页面上的(HTML树+CSS树=渲染树)  



### 简单说下HTTP协议  

HTTP是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。HTTP是一个无状态的协议。    



HTTP协议的特点：  

1.支持客户/服务器模式。支持基本认证和安全认证。

2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。

3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。

4.HTTP 0.9和1.0使用非持续连接：限制每次连接只处理一个请求，服务器处理完客户的请求，并收到客户的应答后，即断开连接。HTTP1.1使用持续连接：不必为每个web对象创建一个新的连接，一个连接可以传送多个对象，采用这种方式可以节省传输时间。

5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。 



HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”(具体内容请参考我的其他文章)。在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。  



HTTP的应用：  

1. 断点续传  
2. 多线程下载  
3. 代理  



参考：[HTTP协议简介](https://juejin.cn/post/6844903888563224583)  



### 了解HTTP中的代理吗？  

**代理服务器的工作流程：**

- 用户向代理发起TCP连接；
- 代理接收用户的连接，双方建立连接；
- 用户向代理发送HTTP请求，请求内容和没有HTTP代理的内容完全相同；
- 代理解析HTTP请求；
- 代理向服务器发起TCP连接；
- 服务器接收代理的连接；
- 代理向服务器发送HTTP请求（这个HTTP请求是基于用户的HTTP请求，可能会有修改）
- 服务器发送响应给代理；

如果不使用代理的话，HTTP的请求报文里会有一个
 `Connection: Keep-Alive`
 如果使用代理的话，HTTP的请求报文里`Connection`就变了
 `Proxy-Connection: Keep-Alive`

**HTTP 代理存在两种形式：普通模式、隧道代理**

- 普通模式

原理：HTTP 客户端向代理服务器发送请求报文，代理服务器需要正确地处理请求和连接（例如正确处理 Connection:keep-alive），同时向目标服务器发送请求，并将收到的响应转发给客户端。

- 隧道代理

原理：HTTP 客户端通过HTTP的CONNECT方法请求隧道代理，创建一条到达任意目的服务器和端口的TCP连接，并对客户端和服务器之间的后继数据进行盲转发。  



### 正向代理与反向代理有什么区别？  

代理可以分为正向代理和反向代理两种。

正向代理需要客户端来配置，一般来说我们会通过浏览器或者操作系统提供的工具或者界面来配置。这个时候，代理对客户端不是透明的，客户端需要知道代理的地址并且手动配置。配置了代理，浏览器在发送请求的时候会对报文做特殊的修改。

反向代理对客户端是透明的，也就是说客户端一般不知道代理的存在，认为自己是直接和服务器通信。我们大部分访问的网站就是反向代理服务器，反向代理服务器会转发到真正的服务器，一般在反向代理这一层实现负载均衡和高可用的功能。而且这里也可以看到，客户端是不会知道真正服务器端的 ip 地址和端口的，这在一定程度上起到了安全保护的作用。



### HTTP状态响应码有哪些？  

罗列一些常见的状态码就行，没必要说那么详细  



参考：[HTTP状态码](https://juejin.cn/post/6844903888563224583#heading-6)   



### HTTP中的请求方法  

HTTP/1.1协议中共定义了八种方法（有时也叫“动作”）来表明Request-URI指定的资源的不同操作方式：

- OPTIONS - 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。
- HEAD- 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。
- GET - 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。
- POST - 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
- PUT - 向指定资源位置上传其最新内容。
- DELETE - 请求服务器删除Request-URI所标识的资源。
- TRACE- 回显服务器收到的请求，主要用于测试或诊断。
- CONNECT - HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
- PATCH - 用来将局部修改应用于某一资源。



### GET与POST请求有什么区别？  

- 请求参数: GET把参数包含在URL中,用&连接起来; POST通过request body传递参数。
- 请求缓存: GET请求会被主动Cache,而POST请求不会，除非手动设置。
- 收藏为书签: GET请求支持收藏为书签, POST请求不支持。
- 安全性: POST比GET安全, GET请求在浏览器回退时是无害的,而POST会再次请求。
- 历史记录: GET请求参数会被完整保留在浏览历史记录里,而POST中的参数不会被保留。
- 编码方式: GET请求只能进行url编码,而POST支持多种编码方式。
- 参数数据类型: GET只接受ASCIl字符,而POST没有限制数据类型。
- 数据包: GET产生一个TCP数据包; POST可能产生两个TCP数据包。  



### HTTP优化策略  

重点：缓存（强缓存与协商缓存，几乎必问）  

* 强制缓存如果生效，不需要再和服务器发生交互
* 而对比缓存不管是否生效，都需要与服务端发生交互。   

对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。

对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

**两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。**      

**浏览器缓存过程**  

1. 浏览器第一次加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把response header及该请求的返回时间一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的时间差，如果没有超过cache-control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存（也就是内存中）读取该文件（如果浏览器不支持HTTP1.1，则用expires判断是否过期）；如果时间过期，则向服务器发送header带有If-None-Match和If-Modified-Since的请求
3. 服务器收到请求后，优先根据Etag的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回200
4. 如果服务器收到的请求没有Etag值，则将If-Modified-Since和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的last-modified和文件并返回200



**产生的缓存一般放在内存中**  



参考：[HTTP前端性能优化(压缩与缓存)](https://juejin.cn/post/6844903940316725255)



### 说一下web缓存？  
1. web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本    
2. 缓存的好处   
   （1）减少不必要的请求  
   （2）降低服务器的压力，减少服务器的消耗  
   （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）  



### 你知道哪些HTTP的头？  

* 请求头：  
  * `accept-encoding` 告诉服务器，我接收的数据支持压缩格式  
  * `if-modified-since` 对比缓存  修改时间   
  *  `if-none-match` 摘要缓存  和`Etag`配对使用的  
  *  `user-agent` 不同设备自动带上这个头   判断什么样的设备，重定向到不同项目  
* 响应头：  
  * `Content-Type`  告诉浏览器  我给你的内容的类型  
  * `Content-Encoding`  告诉浏览器  我给你的内容的压缩格式   
  * `Cache-Control` 强制缓存  告诉浏览器，你多长时间之间，不要来访问我  
  * `Expires`  强缓   告诉浏览器，你多长时间之间，不要来访问我  
  * `Last-Modified` 对比缓存 和 `if-modified-since` 配对使用  
  * `Etag`   根据摘要做缓存   和 `if-none-match` 配对使用  
  *  `Lotaion`  重定向到 某个地方      



### HTTP和HTTPS有什么区别？  

- HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。
- HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。   



HTTPS和HTTP的区别主要如下：
　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。



**HTTPS的优点**

1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。

2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。

3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。  



**HTTPS的缺点（对比优点）**

1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近。

2、HTTPS连接缓存不如HTTP高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响；

3、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

4、HTTPS协议的加密范围也比较有限。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。



### HTTP如何实现长连接？  

- 向的通道,它是可以保持一段时间不关闭的,因此TCP连接才有真正的长连接和短连接这一个说法。
- 长连接是指的是TCP连接,而不是HTTP连接。
- TCP长连接可以复用一个TCP连接来发起多次HTTP请求,这样可以减少资源消耗,比如一次请求HTML,短连接可能还需要请求后续的JS/CSS/图片等

要实现HTTP长连接,在响应头设置Connection为keep-alive, HTTP1.1默认是长连接,而HTTP 1.0协议也支持长连接，但是默认是关闭的。  



### HTTP1.X与HTTP2.X有什么区别？  

1.HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别

2.HTTP2支持多路复用
因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求

3.HTTP2头部压缩
HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了

4.HTTP2支持服务器推送
HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容  



###  cookie, session，localStorage, sessionStorage有什么区别？  

* cookie 服务器种植的，每次请求都会带上cookie，不安全，解决无状态问题，最多4K，浪费流量  
* session 基于cookie  保存在服务器（内存，入库） 相对安全      
* localStorage 不能跨域存取   最大存5M   超过5M的数据就会丢失   在发送请求时，不会带上localStorage  
* sessionStorage 当浏览器关闭时，里面的数据就丢失  



前后端分离（前端调后端api接口）开发的：cookie，**主流：session 或 JWT**        



参考：[理解cookie、session、localStorage、sessionStorage的关系与区别](https://juejin.cn/post/6844903975800537096)    



### 说下JWT与Session有什么区别和优缺点？  



![MJWTAndSession](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/MJWTAndSession.png)



### 说下进程与线程的区别？  

**进程(Process)与线程(Thread)的区别：**

- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
- 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。
- 线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
- 对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。
- 一个程序至少有一个进程,一个进程至少有一个线程.
- 线程的划分尺度小于进程，使得多线程程序的并发性高。
- 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
- 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。



参考：[进程与线程、同步与异步、阻塞与非阻塞、并发与并行](https://juejin.cn/post/6844903848780234759)  



### 进程间的通信方式主要有哪些？    

- 匿名管道
- 命名管道
- 信号量
- 消息队列
- 信号
- 共享内存
- 套接字

从技术上划分又可以划分成以下四种：

1. 消息传递(管道，FIFO，消息队列)
2. 同步(互斥量，条件变量，读写锁等)
3. 共享内存(匿名的，命名的)
4. 远程过程调用



### 说下常见的前端漏洞及防护原理？  

* sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。  
* XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。  
* CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求    



**设置Cookie时如何防止XSS攻击？**  
在服务器端设置cookie的时候设置http-only,这样就可
以防止用户通过JS获取cookie。对cookie的读写或发送
一般有如下字段进行设置:  

 * http-only:只允许http或https请求读取cookie, JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.  
 * secure-only:只允许https请求读取,发送请求时自动发送cookie  
 * host-only:只允许主机域名与domain设置完成一致的网站才能访问该cookie。 



参考：[常见六大Web安全攻防解析](https://juejin.cn/post/6844903772930441230)



## HTML(5)&CSS(3)  



### 说下HTML5都新加了哪些特性？  

HTML5 是定义了 HTML 的标准的最新演进。 这个术语代表了两个不同的概念：

- 它是 HTML 语言的一个新的版本，具有新的元素，属性和行为，
- 以及可以使 Web 站点和应用更加多样化和功能更强大的更丰富的一套技术。 这套技术有时被称作 HTML5 & 它的朋友们 而且往往被缩减到仅是 HTML5。

从要对全部所有的 Web 开发人员有用这一点出发，这个参考页面链接了有关 HTML5 技术的大量资源，并且基于它们各自的功能，把它们归类成了若干组。

- **语义**：能够让你更恰当地描述你的内容是什么。
- **连通性**：能够让你和服务器之间通过创新的新技术方法进行通信。
- **离线 & 存储**：能够让网页在客户端本地存储数据以及更高效地离线运行。
- **多媒体**：使 video 和 audio 成为了在所有 Web 中的一等公民。
- **2D/3D 绘图 & 效果**：提供了一个更加分化范围的呈现选择。
- **性能 & 集成**：提供了非常显著的性能优化和更有效的计算机硬件使用。
- **设备访问 Device Access**：能够处理各种输入和输出设备。
- **样式设计**: 让作者们来创作更加复杂的主题吧。  



### 说下CSS3都新增了哪些特性  

大致说下就行，没必要说那么全。  

在不牺牲性能和语义结构的前提下，CSS3中提供了更多的风格和更强的效果。此外，较之以前的Web排版，Web的开放字体格式(WOFF)也提供了更高的灵活性和控制性。



参考：[CSS3菜鸟教程](https://www.runoob.com/css3/css3-tutorial.html)  



### 说下Flex布局吧  

Flex（Flexible Box）布局 称为 "弹性布局"，可以为网页的布局提供最大的灵活性，取代了往常的 浮动（float） 布局，并且任何一个容器都可以设置 Flex 布局。    

> 注：设置 Flex 布局后，子元素的 Float 布局将失效     

参考： [Flex 布局教程](https://juejin.im/post/5cdfc6ade51d4510a9276955)  



### 说下盒模型

**标准盒子模型和IE盒子模型的区别**

- 在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸
- IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。


参考： [CSS 盒子模型](https://juejin.im/post/5d2dbecb6fb9a07eff00bbc3)    



### CSS中link和@import 的区别是什么？  

* link属于HTML标签，而@import是CSS提供的  
* 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载  
* import只在IE5以上才能识别，而link是HTML标签，无兼容问题  
* link方式的样式的权重 高于@import的权重.  



### 说下CSS的优先级  

不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性  

	1. 属性后面加!import 会覆盖页面内任何位置定义的元素样式
	2. 作为style属性写在元素内的样式
	3. id选择器
	4. 类选择器
	5. 标签选择器
	6. 通配符选择器（*）
	7. 浏览器自定义或继承  

**同一级别：后写的会覆盖先写的**



### 说下transition和animation的区别？  

Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，  

而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。



### 理解BFC吗？  

BFC 即 Block Formatting Contexts (块级格式化上下文)。    

具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。    

通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 



参考：[理解CSS中的BFC](https://juejin.im/post/5da30040f265da5ba273c47d)    



### 使元素消失的方法有哪些?  

visibility:hidden、display:none、z-index=-1、opacity：0    

1. opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发    

2. visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件    

3. display:none, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉  



### 为什么css放在顶部而js写在后面?  

1. 浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了    
2. 其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。      
3. js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验  



但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面    



### CSS会阻塞页面的加载和渲染吗？  

> 前置问题：js会阻塞DOM树的解析和渲染吗？  
>
> 答： 会  

那么CSS加载会阻塞DOM树的解析和渲染吗？  



首先了解一下浏览器渲染的流程：  

- HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
- 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
- 根据Render Tree渲染绘制，将像素渲染到屏幕上。  

从流程我们可以看出来  

* DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。

* 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。

* 由于js可能会操作之前的DOM节点和CSS，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。



**总结**  

由上所述，我们可以得出以下结论:

- css加载不会阻塞DOM树的解析
- css加载会阻塞DOM树的渲染
- css加载会阻塞后面js语句的执行

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

- 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
- 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
- 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
- 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)



### 说下Less与Sass主要用来做什么？  

Less是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量、继承、运算、函数。

Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行。  



Sass是一种动态样式语言，Sass语法属于缩排语法，比CSS多出好多功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。

Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。

Less和Sass在语法上有些共性，比如下面这些：

1. 混入(Mixins)——class中的class；  
2. 参数混入——可以传递参数的class，就像函数一样；  
3. 嵌套规则——Class中嵌套class，从而减少重复的代码；  
4. 运算——CSS中用上数学；  
5. 颜色功能——可以编辑颜色；  
6. 名字空间(namespace)——分组样式，从而可以被调用；  
7. 作用域——局部修改样式；  
8. JavaScript 赋值——在CSS中使用JavaScript表达式赋值。

Less和Sass的主要不同就是他们的实现方式：  

* Less是基于JavaScript，是在客户端处理的。

* Sass是基于Ruby的，是在服务器端处理的。

关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。



### 说下回流(重排)和重绘吧

当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。

* 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少

* 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作  

触发回流的一些情况：

* 页面初次渲染  
* 浏览器窗口大小改变  
* 元素尺寸、位置、内容发生改变  
* 元素字体大小变化  
* 添加或者删除可见的 dom 元素  
* 激活 CSS 伪类（例如：:hover）  
* 查询某些属性或调用某些方法  

```javascript
clientWidth、clientHeight、clientTop、clientLeft
offsetWidth、offsetHeight、offsetTop、offsetLeft
scrollWidth、scrollHeight、scrollTop、scrollLeft
getComputedStyle()
getBoundingClientRect()
scrollTo()
```



**回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。**  



**优化方案：**  

CSS：  

* 避免使用table布局  
* 将动画效果应用到position属性为absolute或fixed的元素上  

JS：  

* 避免频繁操作样式，可汇总后统一 一次修改  
* 尽量使用class进行样式修改  
* 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入  
* 极限优化时，修改样式可将其display: none后修改  
* 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用变量存住    



### 说下BOM与DOM的区别？  

`BOM（Browser Object Model）`是指浏览器对象模型，可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。 使 `JavaScript` 有能力与浏览器"对话"。  


`DOM （Document Object Model）`是指文档对象模型，通过它，可以访问`HTML`文档的所有元素。 `DOM `是 `W3C`（万维网联盟）的标准。`DOM` 定义了访问 `HTML` 和` XML` 文档的标准： "W3C 文档对象模型（DOM）是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 `W3C DOM` 标准被分为 3 个不同的部分：

- 核心 `DOM` - 针对任何结构化文档的标准模型
- `XML DOM` - 针对 XML 文档的标准模型
- `HTML DOM` - 针对 HTML 文档的标准模型

什么是` XML DOM`？ `XML DOM` 定义了所有 XML 元素的对象和属性，以及访问它们的方法。 什么是 HTML DOM？ HTML DOM 定义了所有 HTML 元素的对象和属性，以及访问它们的方法



### href与src有什么区别？  

href是Hypertext Reference的简写，表示超文本**引用**，指向网络资源所在位置。  
常见场景:  

``` 
<a href="http://www.baidu.com"></a> 
<link type="text/css" rel="stylesheet" href="common.css">
```
src是source的简写，目的是要把文件**下载**到html页面中去。  

``` 
<img src="img/girl.jpg"> 
<iframe src="top.html"> 
<script src="show.js">
```
作用结果：  
* href 用于在当前文档和引用资源之间确立联系  
* src 用于替换当前内容    



### 使用REM时给body设置fontSize可以吗？  

> 说下px、em、rem有什么区别？  

这三个的区别是：

* px是固定的像素，一旦设置了就无法因为适应页面大小而改变。  
* em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素<HTML>。**  

但是如果元素自身设置了fontSize，那么em就根据自身进行计算，而不是父元素，如果自身没有设置fontSize，那么就会根据父元素进行设置  





### 实现0.5px的线  

个人感觉是最优解：  

```html
<style>
    .line {
        height: 1px;
        transform: scaleY(0.5);
        transform-origin: 50% 100%;
        background-color: black;
    }
</style>

<body>
    <p>1px + scaleY(0.5)</p>
    <div class='line'></div>
</body>
```



还有一种方法，使用boxshadow：    

这个方法在Chrome和Firefox都非常完美，但是Safari不支持小于1px的boxshadow，所以完全没显示出来。

```html
<style>
    .line {
        height: 1px;
        background: none;
        box-shadow: 0 0.5px 0 #000;
    }
</style>

<body>
    <p>box-shadow: 0 0.5px 0 #000</p>
    <div class='line'></div>
</body>
```



### 如何让一个DIV水平垂直居中？  

```html
<div class="parent">
  <div class="child"></div>
</div>
```

1.   ```css
     div.parent {
         display: flex;
         justify-content: center;
         align-items: center;
     }
     ```

   

2. ```css
   div.parent {
       position: relative; 
   }
   div.child {
       position: absolute; 
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);  
   }
   /* 或者 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       top: 50%;
       left: 50%;
       margin-left: -25px;
       margin-top: -5px;
   }
   /* 或 */
   div.child {
       width: 50px;
       height: 10px;
       position: absolute;
       left: 0;
       top: 0;
       right: 0;
       bottom: 0;
       margin: auto;
   }
   ```

3. ```css
   div.parent {
       display: grid;
   }
   div.child {
       justify-self: center;
       align-self: center;
   }
   ```

4. ```css
   div.parent {
       font-size: 0;
       text-align: center;
       &::before {
           content: "";
           display: inline-block;
           width: 0;
           height: 100%;
           vertical-align: middle;
       }
   }
   div.child{
     display: inline-block;
     vertical-align: middle;
   }
   ```

5. ```css
   div.parent{
     display:flex;
   }
   div.child{
     margin:auto;
   }
   ```

6. ```css
   div.parent {
   	display: table;
   }
   div.child {
       display: table-cell
       vertical-align: middle;
       text-align: center;
   }
   ```



### 如何清除浮动？  

 通常在公共的css样式中定义一个清除浮动的类，哪里需要加哪里  

```css
.clearfix{
	clear:both;
	content:'.';
	display:block;
	width: 0;
	height: 0;
	visibility:hidden;
}
```



### 实现一个三栏布局  

三栏布局，顾名思义就是两边固定，中间自适应  



**流体布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    background-color: blue;
	    float: right;
	}
	.main {
	    margin-left: 120px;
	    margin-right: 220px;
	    height: 200px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**BFC**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.left {
	    float: left;
	    height: 200px;
	    width: 100px;
	    margin-right: 20px;
	    background-color: red;
	}
	.right {
	    width: 200px;
	    height: 200px;
	    float: right;
	    margin-left: 20px;
	    background-color: blue;
	}	
	.main {
	    height: 200px;
	    overflow: hidden;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="left"></div>
        <div class="right"></div>
        <div class="main"></div>
    </div>
</body>
</html>
```



**圣杯布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    margin-left: 120px;
	    margin-right: 220px;
	}
	.main {
	    float: left;
	    width: 100%;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    float: left;
	    width: 100px;
	    height: 300px;
	    margin-left: -100%;
	    position: relative;
	    left: -120px;
	    background-color: blue;
	}
	.right {
	    float: left;
	    width: 200px;
	    height: 300px;
	    margin-left: -200px;
	    position: relative;
	    right: -220px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Flex布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
            display: flex;
	}
	.main {
            flex-grow: 1;
	    height: 300px;
	    background-color: red;
	}
	.left {
	    order: -1;
	    flex: 0 1 200px;
	    margin-right: 20px;
	    height: 300px;
	    background-color: blue;
	}
	.right {
	    flex: 0 1 100px;
            margin-left: 20px;
	    height: 300px;
	    background-color: green;
	}
    </style>
</head>
<body>
    <div class="container">
	<div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**Table布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
        .container {
	    display: table;
	    width: 100%;
        }
        .left, .main, .right {
	    display: table-cell;
        }
        .left {
	    width: 200px;
	    height: 300px;
	    background-color: red;
        }
        .main {
	    background-color: blue;
        }
        .right {
	    width: 100px;
	    height: 300px;
	    background-color: green;
        }
    </style>
</head>
<body>
    <div class="container">
	<div class="left"></div>
	<div class="main"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```



**定位布局**  

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <style>
	.container {
	    position: relative;
	}
	.main {
	    height: 400px;
	    margin: 0 120px;
	    background-color: green;
	}
	.left {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    left: 0;
	    top: 0;
	    background-color: red;
	}
	.right {
	    position: absolute;
	    width: 100px;
	    height: 300px;
	    background-color: blue;
            right: 0;
	    top: 0;
	}
    </style>
</head>
<body>
    <div class="container">
        <div class="main"></div>
	<div class="left"></div>
	<div class="right"></div>
    </div>
</body>
</html>
```





## JS  

前端面试的重中之重，面试的好不好就看你JS玩不6不6  



### JS中的数据类型有哪些？  

八种，分别是：string、number、boolean、undefined、null、symbol(ES6)、bigint(ES10)和object  



> 然后应该会问怎么判断这些数据类型？  

使用typeof、instanceof、原型  



typeof主要用来判断基本数据类型  

instanceof主要用来判断引用数据类型  



不过最好使用原型上的方法判断，是最准确的，写个方法：  

```javascript
function checkType(para) {
    return Object.prototype.toString.call(para).slice(8,-1)  
}
```



### 说下JS中你都用过哪些方法？  

点进去看看：[JS中常用方法总结](https://juejin.cn/post/6844903898189152263)

 

> 追问：说下forEach与Map的区别？  

forEach没有return  

Map可以return，从而组成一个新的数组



### NaN是什么类型的，在什么情况下会出现？  

NaN是属于JavaScript的数值类型Number类型。  
NaN意思是指数据not a number不是一个数字，但是NaN却属于数值类型。  

那么NaN在什么情况下会出现呢？  

```javascript
let a = 'abc'
let b = 5
let c = a * b
console.log(c)

console.log(NaN === NaN) // false
```



### for...in...与for...of...有什么区别？  

for...in 循环只遍历可枚举属性（包括它的原型链上的可枚举属性）。像 Array和Object使用内置构造函数所创建的对象都会继承自Object.prototype和String.prototype的不可枚举属性，例如 String 的 indexOf()  方法或 Object的toString()方法。循环将遍历对象本身的所有可枚举属性，以及对象从其构造函数原型中继承的属性（更接近原型链中对象的属性覆盖原型属性）。  

for...of语句在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句  

无论是for...in还是for...of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。
* for...in语句以任意顺序迭代对象的可枚举属性。  
* for...of 语句遍历可迭代对象定义要迭代的数据。    

总结：  
for in 一般用来遍历对象的key、for of 一般用来遍历数组的value  
for … in

* for … in 获取的是对象的键名;
* for … in会遍历对象的整个原型链,性能非常差不推荐使用;
* 对于数组的遍历,for … in会返回数组中所有可枚举的属性(包括原型链上可枚举的属性);  


for … of
* for … of遍历获取的是对象的键值;
* for … of只遍历当前对象不会遍历原型链;
* 对于数组的遍历,for … of只返回数组的下标对应的属性值;



### 怎么结束for、forEach、Map循环？怎么跳出本轮循环、整个循环和嵌套循环？  

**return语句的作用**  

(1) return 从当前的方法中退出,返回到该调用的方法的语句处,继续执行
(2) return 返回一个值给调用该方法的语句，返回值的数据类型必须与方法的声明中的返回值的类型一致，可以使用强制类型转换来是数据类型一致
(3) return 当方法说明中用void声明返回类型为空时，应使用这种格式，不返回任何值。  



**break语句的作用**  

(1) 只能在循环体内和switch语句体内使用break语句。
(2) 当break出现在循环体中的switch语句体内时，其作用只是跳出该switch语句体。
(3) 当break出现在循环体中，但并不在switch语句体内时，则在执行break后，跳出本层循环体。
(4) 在循环结构中，应用break语句使流程跳出本层循环体，从而提前结束本层循环  



**continue语句作用**  

(1) continue语句的一般形式为：continue;
(2) 其作用是结束本次循环，即跳过本次循环体中余下尚未执行的语句，接着再一次进行循环的条件判定。
(3) 注意：执行continue语句并没有使整个循环终止。在while和do-while循环中，continue语句使得流程直接跳到循环控制条件的测试部分 ，然后决定循环是否继续进行。
(4) 在for 循环中，遇到continue后，跳过循环体中余下的语句，而去对for语句中的“表达式3”求值，然后进行“表达式2”的条件测试，



### `==`与`===`的区别，是否`===`就完全靠谱？  

不一定靠谱，例如 `0 === -0`就为true，`NaN === NaN`为false，判断两个变量是否完全相等可以使用ES6新增的API，`Object.is(0, -0)`，就可以准确区分  



### JS的异步解决方案有哪些？  

* 回调函数（嵌套，回调地狱，不优雅）  
* Promise    
* Generator+co （co可以解决promise嵌套问题）  
* async+await：是Generator的语法糖    

**其实Generator和async+await本质上还是基于Promise实现的**  



参考：  

[JS中的异步解决方案](https://juejin.cn/post/6844903896486264845)  

[深入理解 promise、generator+co、async/await 用法](https://juejin.cn/post/6844903919554920461)    



### 说下Promise的实现原理  

手写Promise，后面《手写原理》会有，看后面  



### 关于Promise.then的链式调用问题  

> then可以链式调用，多个then时，如何走到下一个then的失败回调？  

答：  

1.返回一个失败的promise。  

2.抛出一个错误(throw new Error())    



> then可以链式调用，多个then时，如何终止下一个then的调用？  

答：  

返回一个处于pending(等待态)状态的promise



### 如何把一个伪数组转变为真实的数组？  

* 使用ES6中的展开运算符（ [...obj]，需要保证obj是可迭代的 ）  
* Array.from不需要保证obj是否迭代，内部会使它可迭代     
* 自定义一个genertor迭代器  



### 你都使用过ES6中的哪些语法？  

* let、const  
* 解构赋值  
* 展开运算符  
* 字符串、对象和数组中新加的方法(例：repeat、fill、flat)  
* Set和Map  
* Symbol  
* 箭头函数  
* Reflect和Proxy  
* Class  
* 模块化  
* Promise  

参考：[ES6 新增内容总结](https://juejin.cn/post/6844903902031118344)  



### var、let、const有什么区别？  



点击看下：[区别](https://juejin.cn/post/6844903902031118344#heading-0)  



> 做道题  

```javascript
for(var i=0; i<5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}

// 输出结果是啥  
// 1S 后输出5个5
```

那么我怎么才能按顺序输出0，1，2，3，4呢？  



使用let关键字  

```javascript
for(let i=0; i<5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000)
}

// 输出结果：0,1,3,4,5
```

为什么使用let关键字可以？  

答：因为他会形成一个块级作用域  



如果不适用let关键字怎么解决呢？  

```javascript
for(var i=0; i<5; i++) {
    ((i) => {
        setTimeout(() => {
            console.log(i);
        }, 1000)
    })(i)
}

// 自己形成块级作用域即可
```



### 说下ES6中的模块化  



[点我](https://juejin.im/post/5d3eb1b6f265da03c23eacc2#heading-44)  



### 说下JS中的闭包以及应用场景  

什么是闭包？  

函数执行后返回结果是一个内部函数，并被外部变量所引用，如果内部函数持有被执行函数作用域的变量，即形成了闭包。

可以在内部函数访问到外部函数作用域。使用闭包，一可以读取函数中的变量，二可以将函数中的变量存储在内存中，保护变量不被污染。而正因闭包会把函数中的变量值存储在内存中，会对内存有消耗，所以不能滥用闭包，否则会影响网页性能，造成内存泄漏。当不需要使用闭包时，要及时释放内存，可将内层函数对象的变量赋值为null。  



1. 优点
* 可以从内部函数访问外部函数的作用域中的变量，且访问到的变量长期驻扎在内存中，可供之后使用  
* 避免变量污染全局    
* 把变量存到独立的作用域，作为私有成员存在
2. 缺点
* 对内存消耗有负面影响。因内部函数保存了对外部变量的引用，导致无法被垃圾回收，增大内存使用量，所以使用不当会导致内存泄漏  
* 对处理速度具有负面影响。闭包的层级决定了引用的外部变量在查找时经过的作用域链长度  
* 可能获取到意外的值(captured value)  

应用场景：  

* 函数防抖节流  
* 函数柯里化  
* 使用闭包设计单例模式  
* 为多个组件设置独立属性  
* 设置私有变量  
* 拿到正确的值  



### 堆和栈有什么区别？  

堆中存的是引用数据类型，是动态分配的内存，大小不定也不会自动释放；  

栈中存的是基本数据类型，会自动分配内存空间，自动释放；



- 堆(heap):也可以叫堆内存；是一种队列优先，先进先出的数据结构；
- 栈(stack):又名'堆栈',也是一种数据结构，不过它是按照先进后出原则存储数据的。  




使用JS代码实现队列和栈的功能（就是用数组的增删方法）：  

- 实现队列的方法（先进先出）

```
let arr = new Array();
arr.push(1);
arr.push(2);
arr.shift();
复制代码
```

- 实现栈的方法（先进后出）

```
let arr = new Array();
arr.push(1);
arr.push(2);
arr.pop();
```



### 说下EventLoop(事件环)  



[JS(浏览器)事件环 (宏、微任务)](https://juejin.cn/post/6844903914085564423)  



### 说下JS中的原型和原型链  

参考：[JavaScript 原型 与 原型链](https://juejin.cn/post/6844903914085564423)  



```javascript
function A() {}
let a = new A()

// console.log(a.__proto__ == A.prototype) // true

// console.log(A.prototype.__proto__ == Object.prototype)  // true

// console.log(Object.prototype.__proto__ == null)  // true

// console.log(A.prototype.constructor == A)   // true
```



### 说下JS中的作用域和作用域链  



参考：[JavaScript 作用域 与 作用域链](https://juejin.cn/post/6844903901074980871)  



### JS中new做了什么？  

- 创建了一个空对象
- 绑定this值
- 链接到原型
- 返回新对象  



参考：[JS中 new究竟做了什么？](https://juejin.cn/post/6844903896326864910)  



### 说下箭头函数和普通函数有什么区别？  

主要区别就是this关键字的问题  

箭头函数中没有this  

**箭头函数中谁调用了包含this的方法，那么this就指向谁**      



> 这时候十有八九会让你做道题，后面做题环节再试下  



### 怎么改变this的指向？  



参考：[JS中改变this的指向 call、apply 和 bind 的区别](https://juejin.cn/post/6844903895743856654)  



### JS常见的设计模式"  

* 构造函数设计模式  
* 原型模式  
* 模块设计模式  
* 单例模式  
* 工厂模式  
* 观察者模式  
* 命令模式  
* 装饰模式  
* MVC模式  
* MVVM模式    



### 观察者模式和发布订阅模式有什么区别？  



观察者模式中： 
* 状态发布者维护了一个观察者的列表，明确的知道有哪些观察者存在，将状态变化直接通知给观察者
* 状态的观察者也明确的知道自己观察的状态是描述的哪一个对象
* 甚至需要这种相互知道的关系来处理逻辑（比如需要明确知道哪一个按钮被点击，处理对应的逻辑）

发布订阅模式：  
* 事件的发布者只发布事件，不关心这个事件被谁获取了，通常将事件发给一个中间件，由中间件再去分发事件
* 事件的订阅者只关心事件本身，不关心这个事件是谁发布的，通常在中间件中去注册观察某个事件
* 中间件中去维护事件类别对应的订阅者列表，当收到事件后，去对应列表中通知订阅者们  

参考：[两种模式讲解](https://juejin.cn/post/6844903921211670536)    



> 追问：能给我简单实现这两种模式吗？  

**观察者模式简单实现**

```javascript
//被观察者
class Subject{
    constructor(){
        this.arr = []   //存储观察者
        this.state = "开心..."  //存储被观察者状态
    }
    attach(unit){
        this.arr.push(unit)
    }
    //改变状态
    setState(newState){
        this.state = newState
        this.arr.forEach(unit=>unit.update(newState))
    }
}
//观察者
class Observer{
    constructor(name){
        this.name = name
    }
    update(newState){
        console.log(this.name,"状态：",newState);
    }
}
let s = new Subject("宝宝")
let o1 = new Observer("我")
let o2 = new Observer("你")

s.attach(o1)
s.attach(o2)
console.log(s.state);   //开心...
s.setState("不开心...");    //我 状态： 不开心...   你 状态： 不开心...
console.log(s.state);   //不开心...
```



**发布订阅简单实现**  

```javascript
let e = {
    arr:[],
    on(fn){
        this.arr.push(fn)
    },
    emit(){
        this.arr.forEach(fn=>fn())
    }
}
e.on(()=>{
    console.log("哈哈 1");
})
e.on(()=>{
    console.log("哈哈 2");
})

//调一次打印一次
e.emit()    //哈哈 1  哈哈 2  
e.emit()    //哈哈 1  哈哈 2 
```







### JS阻止冒泡和取消默认事件  

防止冒泡和捕获：    

w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true  

stopPropagation也是事件对象(Event)的一个方法，作用是阻止目标元素的冒泡事件，但是会不阻止默认行为。什么是冒泡事件？如在一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发 。stopPropagation就是阻止目标元素的事件冒泡到父级元素。    



取消默认事件：   

w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;    



总结使用方法：
当需要停止冒泡行为时，可以使用  

```javascript
function stopBubble(e) { 
//如果提供了事件对象，则这是一个非IE浏览器 
if ( e && e.stopPropagation ) 
    //因此它支持W3C的stopPropagation()方法 
    e.stopPropagation(); 
else 
    //否则，我们需要使用IE的方式来取消事件冒泡 
    window.event.cancelBubble = true; 
}
```



当需要阻止默认行为时，可以使用    

```javascript
//阻止浏览器的默认行为 
function stopDefault( e ) { 
    //阻止默认浏览器动作(W3C) 
    if ( e && e.preventDefault ) 
        e.preventDefault(); 
    //IE中阻止函数器默认动作的方式 
    else 
        window.event.returnValue = false; 
    return false; 
}
```



### JS是如何运行的？”  

JS代码 ——>解析成AST (期间伴随词法分析、语法分析)——>生成字节码(V8)——>生成机器码(编译器)



### Jquery的优点？  

1.轻量
2.丰富的DOM选择器
3.链式表达式
4.事件、样式、动画支持
5.跨浏览器兼容
6.可扩展性  



### 怎么判断DOM加载完成？  

判断所有DOM加载完成使用onload  

``` javascript
window.onload = function(){
    
}
```
判断某个DOM节点是否加载完毕  

**readyState**  

document.readyState 返回当前文档的状态，属性如下： 
* uninitialized 还未开始加载
* loading 加载中
* interactive 已加载，文档与用户可以开始交互
* complete 加载完成

**DOMContentLoaded**    

当 DOMContentLoaded事件触发时，仅当DOM加载完成，不包括样式表，图片，flash  



### Jquery(callback)这个callback有什么用？  

当传进去的参数是函数的时候，则在document对象上绑定一个ready事件监听函数，当DOM结构加载完成的时候执行    



```javascript
$(function(){

})
//以上代码和下面的效果是一样的
$(document).ready(function(){
    ...//代码
})
```



### Jquery与Zepto有什么区别？  

Zepto专用于手机端    

jQuery专用于pc端 （但jq又开发出了jquery-mobile,专门用于手机）    

* Zepto特点：Zepto是为现代智能手机浏览器推出的Javascript 框架, 有着和jQuery相似的语法, 但是和jQuery相比下来, 他有很多的优点, 在大小方面 , 压缩后的 zepto.min.js 大小只有21K, 使用服务器端 gzip 压缩后大小只有5~10K, 可以说非常的小, 功能很齐全, 并且多出来了一些触摸屏的事件,它对PC的浏览器就不是那么理想,尤其是在IE上直接过滤不兼容, 所以这个轻量级的js用它来开发手机端和iOS，Android网页都是是不错的选择，极大的减轻了整个app的负载量。  

* jquery特点：jquery主要是用于PC端的页面开发中，jquery是目前最流行的javascript框架，以其兼容全部主流浏览器，插件丰富，代码简洁，最关键的是更新快，其中最好的dom选择器被广泛的使用。而手机wap方面的话，jquery也推出jquery-mobile，也很好用。  

* 相同点：Zepto最初是为移动端开发的库，是jQuery的轻量级替代品，因为它的API和jQuery相似，而文件更小。Zepto最大的优势是它的文件大小，只有8k多，是目前功能完备的库中最小的一个，尽管不大，Zepto所提供的工具足以满足开发程序的需要。大多数在jQuery中·常用的API和方法Zepto都有，Zepto中还有一些jQuery中没有的。另外，因为Zepto的API大部分都能和jQuery兼容，所以用起来极其容易，如果熟悉jQuery，就能很容易掌握Zepto。你可用同样的方式重用jQuery中的很多方法，也可以方面地把方法串在一起得到更简洁的代码，甚至不用看它的文档。  

* 不同点：  
  * 针对移动端程序，Zepto有一些基本的触摸事件可以用来做触摸屏交互（tap事件、swipe事件），Zepto是不支持IE浏览器的，这不是Zepto的开发者Thomas Fucks在跨浏览器问题上犯了迷糊，而是经过了认真考虑后为了降低文件尺寸而做出的决定，就像jQuery的团队在2.0版中不再支持旧版的IE（6 7 8）一样。因为Zepto使用jQuery句法，所以它在文档中建议把jQuery作为IE上的后备库。那样程序仍能在IE中，而其他浏览器则能享受到Zepto在文件大小上的优势，然而它们两个的API不是完全兼容的，所以使用这种方法时一定要小心，并要做充分的测试。  
  * Dom操作的区别  
  * 事件触发的区别  
  * 事件委托的区别  
  * width()和height()的区别：Zepto由盒模型(box-sizing)决定，jQuery会忽略盒模型  
  * 等等。。。  



### JS隐式类型转换了解过吗？  

先说出下面代码执行结果(当时面试的时候做错了)

```javascript
if([] == false) {
  console.log(1)
}

if({} == false) {
  console.log(2)
}

if([]) {
  console.log(3)
}

if([1] == [1]) {
  console.log(4)
}
```



**使用==比较中的5条规则**  

* 规则 1：`NaN`和其他任何类型比较永远返回`false`（包括和他自己）  
* 规则 2：`Boolean `和其他任何类型比较，`Boolean `首先被转换为 `Number `类型    
* 规则 3：`String`和`Number`比较，先将`String`转换为`Number`类型。  
* 规则 4：`null == undefined`比较结果是`true`，除此之外，`null`、`undefined`和其他任何结果的比较值都为`false`。  
* 规则 5：`原始类型`和`引用类型`做比较时，引用类型会依照`ToPrimitive`规则转换为原始类型。



**类型转换表**  



![convert-table](https://raw.githubusercontent.com/github-fanjunyang/Notes/main/images/convert-table.png)



参考：[JavaScript 隐式类型转换](https://chinese.freecodecamp.org/news/javascript-implicit-type-conversion/)    



## Vue  



## React  



## 后端&运维  



## 算法题&手写原理  



## 项目相关  

### 实现REM适配  

```javascript
<script>
	;(function () {
		// 设计稿宽度 px
		var designWidth = 375
		// rem 基准字号 px
		var baseFontSize = 100
		// 最大适配宽度 px
		var maxAdaptWidth = 1024

		var adaptDevice = function () {
			var deviceWidth = document.documentElement.clientWidth
			deviceWidth = deviceWidth > maxAdaptWidth ? maxAdaptWidth : deviceWidth
			var scale = deviceWidth / designWidth
			var adaptRootFontSize = baseFontSize * scale
			document.querySelector('html').style.fontSize = adaptRootFontSize + 'px'
		}

		var timer = 0
		window.addEventListener('resize', function () {
			if (timer) {
				clearTimeout(timer)
				timer = 0
			}

			timer = setTimeout(function () {
				adaptDevice()
			}, 0)
		})

		setTimeout(adaptDevice, 0)
	}())
</script>
```





# 非技术相关   

参考我的文章：[【非技术性问题】](https://juejin.cn/post/6844904008335753224)  

