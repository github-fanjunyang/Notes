---
title: 面试算法题 
---  
[toc]  

# 二分查找  

``` 
// 二分查找（递归）
function searchTwo (target, array, start, end) {
    if (start > end) return -1
    start = start || 0
    end = end || array.length - 1
    let mid = parseInt((end - start) / 2 + start)
    if (target == array[mid]) {
        return mid
    }
    if (target > array[mid]) {
        return searchTwo(target, array, mid + 1, end)
    }
    if (target < array[mid]) {
        return searchTwo(target, array, start, mid - 1)
    }
}

// console.log(searchTwo(5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 18, 58, 42]));
```
# 最大子序和  

``` 
// 最大子序和
function maxAddArray (array) {
    let max = array[0]
    let m = 0
    for (let i = 0; i < array.length; i++) {
        m = Math.max( m + array[i], array[i])
        max = Math.max(max, m)
    }
    return max
}

// console.log(maxAddArray([-2, 1, -3, 4, -1, 2, 1, -5, 4]));


// max -2  (-2, -2) = -2   (-2, 1) = 1     (1, -2) = 1     (1, 4) = 4  (4, 3) = 4  (4, 5) = 5  (5, 6) = 6  (6, 1) = 6

// m   0   (-2, -2) = -2   (-1, 1) = 1     (-2, -3) = -2   (2, 4) = 4  (3, -1) = 3 (5, 2) = 5  (6, 1) = 6  (1, -5) = 1
```

# 将N维数组转化为一维数组  

``` 
// 将二维数组转化为一维数组
function twoOneArray (array) {
    return array.reduce((p, i) => [...p, ...i], [])
}

// console.log(twoOneArray([[0, 1], [2, 3], [4, 5]]))

/***************************************************************************** */

// 将多维数组转化为一维
function someToOne (array) {
    return array.reduce((p, i) => p.concat(Array.isArray(i) ? someToOne(i) : i), [])
}

// console.log(someToOne([[0, 1], [2, 3], [4,[5,6,7]]]))

/***************************************************************************** */
```

# 原型与原型链  

``` 
// 原型与原型链
function A() {}
let a = new A()

// console.log(a.__proto__ == A.prototype) // true

// console.log(A.prototype.__proto__ == Object.prototype)  // true

// console.log(Object.prototype.__proto__ == null)  // true

// console.log(A.prototype.constructor == A)   // true
```

# 手写new原理  

``` 
function B(name, age) {
    this.name = name
    this.age = age
}

// 手写new原理
function create() {
    // 创建空对象
    let obj = new Object()
    // 获取构造函数
    let Constructor = [].shift.call(arguments)
    // 链接到原型
    obj.__proto__ = Constructor.prototype
    // 绑定this
    let result = Constructor.apply(obj, arguments)
    // 返回新对象,(如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象)
    return typeof result === 'object' ? result : obj
}

let b1 = new B('fan', 18)
let b2 = create(B, 'jun', 20)
```

# 函数柯里化  

``` 
// 函数柯里化
function toCurry(fn, ...args) {

    if(args.length >= fn.length) {
        return fn.apply(null, args);
    }

    return (...args2) => toCurry(fn, ...args, ...args2);
}

const add = toCurry(function(a, b, c) {
    return a + b + c;
});

// console.log(add(1, 2, 3))
// console.log(add(1)(2)(3))
// console.log(add(1, 2)(3))
// console.log(add(1)(2, 3))
```  

# 深拷贝  

``` 
// 深拷贝
function deepClone(source) {
    // 判断复制的目标是数组还是对象
    const target = source.constructor === Array ? [] : {}
    // 遍历目标
    for (const key in source) {
        if (source[key] && typeof source[key] === 'object') {
            // 对象 || 数组
            target[key] = source[key].constructor === Array ? [] : {}
            target[key] = deepClone(source[key])
        } else {
            // 不是对象或者数组，直接赋值
            target[key] = source[key]
        }
    }
    return target
}

let str1 = {
    name: 'fan',
    arr: [1, 2, 3],
    obj: {
        key: 'value'
    },
    fn: function () {
        return 1;
    }
};
let str2 = deepClone(str1);
str2.name = 'jun'

// console.log(str1.name === str2.name) // false
// console.log(str2 === str1) // false
// console.log(str2.obj === str1.obj) // false
// console.log(str2.fn === str1.fn) // true
```

# 求数组交集、并集、差集  

``` 
// 求数组交集、并集、差集

// 交集
function intersection1(arr1, arr2) {
    return [...new Set(arr1)].filter(i => {
        return new Set(arr2).has(i)
    })
}

function intersection2(arr1, arr2) {
    return arr1.reduce((i, v) => {
        if (arr2.includes(v)) i = [...i, v]
        return i
    }, [])
}

// 并集
function union1(arr1, arr2) {
    return [...new Set([...arr1, ...arr2])]
}

function union2(arr1, arr2) {
    return [...arr1, ...arr2].reduce((i, v) => {
        if ((arr1.includes(v) || arr2.includes(v)) && !i.includes(v)) i = [...i, v]
        return i
    }, [])
}

// 差集
function difference1(arr1, arr2) {
    return [...[...new Set(arr1)].filter(i => !new Set(arr2).has(i)),
            ...[...new Set(arr2)].filter(i => !new Set(arr1).has(i))]
}

function difference2(arr1, arr2) {
    return [...arr1, ...arr2].reduce((i, v) => {
        if (!arr1.includes(v) || !arr2.includes(v)) i = [...i, v]
        return i
    }, [])
}

// console.log(intersection1([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(intersection2([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(union1([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(union2([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(difference1([1, 2, 3, 4], [3, 4, 5, 6]))
// console.log(difference2([1, 2, 3, 4], [3, 4, 5, 6]))

```
# 防抖节流  

``` 
// 防抖节流

// 防抖(在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时)
function debounce(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        clearTimeout(timer)
        timer = setTimeout(() => {
            // 改变this指向并传递参数
            fn.apply(this, arguments)
        }, t)
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test(e) {
        // 如果debounce不加参数arguments，这里会打印undefined
        console.log(e)
        // 如果debounce不改变this指向，这里会打印window,而不是DOM节点
        console.log(this)
        container.innerHTML = count++;
    }
    function debounce(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            clearTimeout(timer)
            timer = setTimeout(() => {
                fn.apply(this, arguments)
            }, t)
        }
    }
    container.onmousemove = debounce(test, 1000)
</script>

 */

// 节流(规定在一个单位时间内，只能触发一次函数，如果这个单位时间内触发多次函数，只有一次生效)
function throttle(fn, delay) {
    let t = delay || 500
    let timer
    return function() {
        if (!timer) {
            timer = setTimeout(() => {
                // 为了方便下次执行定时器
                timer = null
                fn.apply(this, arguments)
            }, t)
        }
    }
}

/**

HTML代码示例

<body>
    <div id="container"></div>
</body>
<script>
    let count = 1
    let container = document.getElementById('container')
    function test() {
        container.innerHTML = count++;
    }
    function throttle(fn, delay) {
        let t = delay || 500
        let timer
        return function() {
            if (!timer) {
                timer = setTimeout(() => {
                    // 为了方便下次执行定时器
                    timer = null
                    fn.apply(this, arguments)
                }, t)
            }
        }
    }
    container.onmousemove = throttle(test, 2000)
</script>

 */
```
# 统计字符串或者数组中字符出现的次数  

``` 
// 统计字符串或者数组中字符出现的次数
function strArrNum(params) {
    let arr = []
    params instanceof Array
        ? arr = params
        : arr = params.split('')
    return arr.reduce((i ,v) => {
        if (i[v]) {
            i[v] += 1
        } else {
            i[v] = 1
        }
        return i
    }, {})
}

// console.log(strArrNum('aiusgdkhhcasdasdasdjhbcdshb'))

// 扩展，取出现最多的字符
const finalRes = strArrNum('aiusgdkhhcasdasdasdjhbcdshb')

let finalArr = []
for (const key in finalRes) {
    if (finalRes[key] === Math.max(...Object.values(finalRes))) {
        finalArr.push(key)
    }
}

// console.log(finalArr)

```
# 阶乘  

``` 
// 阶乘
function factorial (num) {
    if (num < 0) return -1
    return num === 1 ? 1 : num * factorial (--num)
}

// console.log(factorial (5))
```

# 驼峰与下划线之间互转  

``` 
// 驼峰与下划线之间互转

// 下划线转驼峰
function toHump(str) {
    // _代表匹配的整体字符串,l表示匹配正则的()分组
    return str.replace(/_(\w)/g, (_, l) => {
        return l.toUpperCase();
    });
}

// console.log(toHump('hello_word'))

// 驼峰转下划线
function toLine(str) {
    return str.replace(/([A-Z])/g,"_$1").toLowerCase();
}

// console.log(toLine('helloWord'))
```

# 数组排序（冒泡、选择、快排等）  

``` 
// 数组排序（冒泡、选择、快排等）

// 冒泡排序(两两比较)
function bubbleAsSort(arr) {
    for (let i = 0; i < arr.length - 1; i++) {
        for (let j = 0; j < arr.length - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                let temp = arr[j + 1]
                arr[j + 1] = arr[j]
                arr[j] = temp
            }
        }
    }
    return arr
}

// console.log(bubbleAsSort([2,9,5,8,6,4,3,7]))

// 选择排序(遍历自身以后的元素，最小的元素跟自己调换位置)
function selectAsSort(arr) {
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - 1; j++) {
            if (arr[j] < arr[i]) {
                [arr[i], arr[j]] = [arr[j], arr[i]]
            }
        }
    }
    return arr
}

// console.log(selectAsSort([2,9,5,8,5,6,4,3,7]))
```

# 斐波那契数列  

``` 
// 斐波那契数列
// 斐波那契数列（Fibonacci sequence），又称黄金分割数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）

// 采用递归（存在重复调用缺陷）
function fib(n) {
    if (n < 2) return 1
    return fib(n - 2) + fib(n - 1)
}

// console.log(fib(6))

// 递归优化 空间复杂度O(n),将函数执行结果用变量缓存起来的方法。当函数进行计算之前，先看缓存对象中是否有次计算结果，如果有，就直接从缓存对象中获取结果；如果没有，就进行计算，并将结果保存到缓存对象中
function fibonacciOn(n) {
    // 用一个数组来存储斐波那契数字
    const cache = [0, 1]
    for (let i = 2; i <= n; i++) {
        cache[i] = cache[i - 1] + cache[i - 2]
    }
    return cache[n]
}

// console.log(fibonacciOn(6))

// 递归优化 空间复杂度O(1)
function fibonacciO1(n, current = 0, next = 1) {
    for(let i = 0; i < n; i++) {
        [current, next] = [next, current + next]
    }
    return current
}

// console.log(fibonacciO1(6))

// 尾递归(只在严格模式下才能使用)
'use strict'
function fibTail(n, current = 0, next = 1) {
    if(n == 0) return 0;
    if(n == 1) return next
    return fibTail(n - 1, next, current + next)
}

// console.log(fibTail(6))
```

